{"config":{"lang":["en"],"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Pr\u00e1ticas de Implementaci\u00f3n e Implantaci\u00f3n de Sistemas Software Programaci\u00f3n orientada a objetos Pr\u00e1ctica 1 Pr\u00e1ctica 2 Pr\u00e1ctica 3 Pr\u00e1ctica 4 Programaci\u00f3n funcional Pr\u00e1ctica 1 Pr\u00e1ctica 2 Programaci\u00f3n dirigida por eventos Pr\u00e1ctica 1 Pr\u00e1ctica 2 Pr\u00e1ctica 3","title":"Home"},{"location":"#praticas-de-implementacion-e-implantacion-de-sistemas-software","text":"","title":"Pr\u00e1ticas de Implementaci\u00f3n e Implantaci\u00f3n de Sistemas Software"},{"location":"#programacion-orientada-a-objetos","text":"Pr\u00e1ctica 1 Pr\u00e1ctica 2 Pr\u00e1ctica 3 Pr\u00e1ctica 4","title":"Programaci\u00f3n orientada a objetos"},{"location":"#programacion-funcional","text":"Pr\u00e1ctica 1 Pr\u00e1ctica 2","title":"Programaci\u00f3n funcional"},{"location":"#programacion-dirigida-por-eventos","text":"Pr\u00e1ctica 1 Pr\u00e1ctica 2 Pr\u00e1ctica 3","title":"Programaci\u00f3n dirigida por eventos"},{"location":"ep-p1/","text":"Pr\u00e1ctica 1 TO DO","title":"Pr\u00e1ctica 1"},{"location":"ep-p1/#practica-1","text":"","title":"Pr\u00e1ctica 1"},{"location":"ep-p1/#to-do","text":"","title":"TO DO"},{"location":"ep-p2/","text":"Pr\u00e1ctica 2 TO DO","title":"Pr\u00e1ctica 2"},{"location":"ep-p2/#practica-2","text":"","title":"Pr\u00e1ctica 2"},{"location":"ep-p2/#to-do","text":"","title":"TO DO"},{"location":"ep-p3/","text":"Pr\u00e1ctica 3 TO DO","title":"Pr\u00e1ctica 3"},{"location":"ep-p3/#practica-3","text":"","title":"Pr\u00e1ctica 3"},{"location":"ep-p3/#to-do","text":"","title":"TO DO"},{"location":"fp-p1/","text":"Pr\u00e1ctica 1 TO DO","title":"Pr\u00e1ctica 1"},{"location":"fp-p1/#practica-1","text":"","title":"Pr\u00e1ctica 1"},{"location":"fp-p1/#to-do","text":"","title":"TO DO"},{"location":"fp-p2/","text":"Pr\u00e1ctica 2 TO DO","title":"Pr\u00e1ctica 2"},{"location":"fp-p2/#practica-2","text":"","title":"Pr\u00e1ctica 2"},{"location":"fp-p2/#to-do","text":"","title":"TO DO"},{"location":"oop-p1/","text":"Pr\u00e1ctica 1: Herencia, composici\u00f3n y polimorfismo Repaso de conceptos te\u00f3ricos Herencia Definici\u00f3n Se puede definir la herencia como el mecanismo por el cual una clase permite heredar sus caracter\u00edsticas (atributos y m\u00e9todos) a otra clase. Este mecanismo puede ser usado para la reutilizaci\u00f3n de c\u00f3digo, la cual permite realizar extensiones independientes del software original. por Carlos Villag\u00f3mez, Enciclopedia de Programaci\u00f3n Orientada a Objetos En el ejemplo de la imagen anterior existe una jerarqu\u00eda de herencia de tres niveles en los que: Todas las clases heredan las funciones y propiedades de la clase \"Animal\". La clase \"Conejo\" hereda las funciones y propiedades de la clase \"Herb\u00edvoro\", las clases \"Le\u00f3n\" y \"Hiena\" las de la clase \"Carn\u00edvoro\" y la clase \"Hombre\" las de la clase \"Omn\u00edvoro\". \u00bfCu\u00e1ndo utilizar la herencia? La herencia debe ser utilizada cuando se cumplen al menos las siguientes condiciones: Existe una relaci\u00f3n \"es un/una\" entre las entidades . Por ejemplo: un le\u00f3n o una hiena son animales, pero un animal no tiene porque ser un le\u00f3n (puede ser cualquiera de las otras subclases). Esto es debido a que la relaci\u00f3n de herencia es unidireccional. Se conoce el 100% de los requisitos del software y \u00e9stos no van a cambiar . Si se conoce perfectamente los requisitos del software que se va a implementar y estos no van a cambiar, se puede deducir las relaciones de herencia que existir\u00e1n entre las clases desde el principio. No obstante, en cualquier otro caso puede ser costoso durante el desarrollo eliminar/mantener estas relaciones si los requisitos van evolucionando en otro sentido. Por ejemplo, esto suceder\u00eda dentro de un proyecto donde se aplica una metodolog\u00eda de desarrollo \u00e1gil. Polimorfismo en la herencia La herencia otorga la propiedad de polimorfismo, que significa que cualquiera de las subclases pueden adoptar la forma de la superclase. Esta es una de las principales ventajas de la herencia, ya que el polimorfismo permite la abstracci\u00f3n del objeto concreto y usar su superclase. Por ejemplo, podr\u00edamos tratar cualquier instancia de la clase \"Hombre\" o \"Le\u00f3n\" como una instancia de la clase \"Animal\", ya que han herendado todas sus funciones y propiedades. Pero no al contrario, ya que la clase \"Le\u00f3n\" podr\u00eda haber a\u00f1adido nuevas propiedades o funciones que no est\u00e9n disponibles en la clase \"Animal\". \u00bfCu\u00e1les son las ventajas de la herencia? Las ventajas que nos propone el uso de la herencia son las siguientes: Permite reutilizar c\u00f3digo de una manera r\u00e1pida y sencilla. Permite el uso del polimorfismo con facilidad. Permite sobreescribir m\u00e9todos, adapt\u00e1ndolos a necesidades espec\u00edficas. Permite crear clases abstractas que hacen de plantilla a las subclases (parecido al patr\u00f3n de dise\u00f1o \"Template Method\"). Composici\u00f3n Definici\u00f3n La composici\u00f3n se basa en la creaci\u00f3n de clases que realizar\u00e1n una \u00fanica y espec\u00edfica funci\u00f3n que complementaran a otras clases, las cuales estar\u00e1n compuestas por ellas. Este mecanismo, nos permitir\u00e1 delegar las funciones a aquellas clases que se han implementado \u00fanicamente para cubrirlas, reutilizando su c\u00f3digo fuente donde sea necesario. por Arturo Verbel de Le\u00f3n, Diagrama de clases para dummies En el ejemplo anterior se puede observar: La clase \"Empresa\" esta compuesta por instancias de la clase \"Empleado\". La clase \"Empleado\" es el compuesto de la clase \"Empresa\", de hecho se establece una relaci\u00f3n donde la cardinalidad es 1..N por lo que la clase \"Empresa\" en su implementaci\u00f3n mantendr\u00e1 una lista de instancias de la clase \"Empleado\". \u00bfCu\u00e1ndo utilizar la composici\u00f3n? La composici\u00f3n debe ser utilizada cuando se cumplen al menos las siguientes condiciones: No existe una relaci\u00f3n \"es un/una\" entre las entidades, si no \"tiene\" . Por ejemplo: a una persona que le encanta correr se le podr\u00eda clasificar como \"runner\", pero establecerlo como herencia ser\u00eda un error, ya que la persona con el paso del tiempo podr\u00eda dejar de serlo. En este caso, ser\u00eda m\u00e1s correcto decir que tiene el \"rol\" de runner usando la composici\u00f3n, pudi\u00e9ndolo eliminar cuando fuese necesario. No se conocen 100% los requisitos del software y \u00e9stos ser\u00e1n actualizados . Cuando no se conocen por completo los requisitos del sistema es m\u00e1s correcto no establecer relaciones de herencia que pudiesen ser eliminadas posteriormente. Por este motivo, crear clases con las funciones espec\u00edficas y vincularlas a otras haciendo uso de la composici\u00f3n, proporciona mayor flexibilidad y tolerancia a cambios en la implementaci\u00f3n. Adem\u00e1s, permite modularizar el sistemma de forma de que sea posteriormente m\u00e1s facil de mantener. Polimorfismo en la composici\u00f3n La composici\u00f3n por si misma no es polim\u00f3rfica, lo cual puede ser de sus mayores desventajas. No obstante, esto puede ser facilmente solventado con el uso de interfaces. De esta manera, los objetos compuestos implementar\u00e1n las interfaces que interese en cada situaci\u00f3n, consiguiendo a\u00f1adir/eliminar las funciones que implementan sin necesidad de afectar a la funcionalidad propuesta por otras clases. por Sergio Mart\u00ednez Rodr\u00edguez, Herencia vs Composici\u00f3n \u00bfTienes claro cu\u00e1l es el rival m\u00e1s d\u00e9bil? En el ejemplo anterior se puede observar: La clase \"MainActivity\" tiene una funcionalidad dada por un elemento que contiene de la clase \"NavigationDelegate\". Por otro lado, la forma de notificar al resto de clases de que proporciona la funcionalidad \"navigate()\" es implementando la interfaz \"NavigationInterface\". Cuando la clase \"MainActivity\" no deba proporcionar la funcionalidad \"navigate()\" \u00fanicamente debe dejar de implementar la interfaz \"NavigationInterface\" y eliminar la instancia de la clase \"NavigationDelegate\" o dejar de invocar a su funci\u00f3n \"navigate()\". Herencia vs composici\u00f3n Como se ha comentado anteriormente, la herencia es un mecanismo muy potente para reutilizar c\u00f3digo fuente, pero no siempre es la mejor t\u00e9cnica para conseguir este objetivo. Ya que, si se usa la herencia de forma inapropiada se puede conseguir software poco seguro y robusto. Adem\u00e1s, el uso de herencia viola el principio de encapsulaci\u00f3n, ya que la subclase siempre depender\u00e1 de la implementaci\u00f3n de los m\u00e9todos en la superclase (a no ser que los sobreescriba), y \u00e9stos m\u00e9todos se actualizar\u00e1n en futuras versiones, con lo que se conseguir\u00e1 incertidumbre en la funcionalidad del c\u00f3digo fuente programado. A continuaci\u00f3n, se muestra una tabla que incluye las diferencias de uso entre la herencia y la composici\u00f3n en algunas de las etapas del desarrollo software y en otros aspectos de inter\u00e9s: por Sergio Mart\u00ednez Rodr\u00edguez, Herencia vs Composici\u00f3n \u00bfTienes claro cu\u00e1l es el rival m\u00e1s d\u00e9bil? Ejercicios propuestos Ejercicio 1 Dado los siguientes fragmentos de c\u00f3digo responder a las siguientes preguntas: ElementsSet.java public class ElementsSet < E > extends HashSet < E > { //Number of attempted elements insertions using the \"add\" method private int numberOfAddedElements = 0 ; public ElementsSet () {} @Override public boolean add ( E element ) { numberOfAddedElements ++ ; //Counting the element added return super . add ( element ); } @Override public boolean addAll ( Collection <? extends E > elements ) { numberOfAddedElements += elements . size (); //Counting the elements added return super . addAll ( elements ); } public int getNumberOfAddedElements () { return numberOfAddedElements ; } } Main.java ... ElementsSet < String > set = new ElementsSet < String > (); set . addAll ( Arrays . asList ( \"One\" , \"Two\" , \"Three\" )); System . out . println ( set . getNumberOfAddedElements ()); ... Preguntas propuestas a) \u00bfEs el uso de herencia adecuado para la implementaci\u00f3n de la clase \"ElementsSet\"?, \u00bfqu\u00e9 salida muestra la funci\u00f3n \"System.out.println\" al invocar el m\u00e9todo \"getNumberOfAddedElements\", 3 o 6?. b) En el caso de que haya alg\u00fan problema en la implementaci\u00f3n anterior, proponga una soluci\u00f3n alternativa usando composici\u00f3n que resuelva el problema. Ejercicio 2 Dado los siguientes fragmentos de c\u00f3digo responder a las siguientes preguntas: Animal.java public abstract class Animal { //Number of legs the animal holds protected int numberOfLegs = 0 ; public abstract String speak (); public abstract boolean eat ( String typeOfFeed ); public abstract int getNumberOfLegs (); } Cat.java public class Cat extends Animal { @Override public String speak () { return \"Meow\" ; } @Override public boolean eat ( String typeOfFeed ) { if ( typeOfFeed . equals ( \"fish\" )) { return true ; } else { return false ; } } @Override public int getNumberOfLegs () { return super . numberOfLegs ; } } Dog.java public class Dog extends Animal { @Override public String speak () { return \"Woof\" ; } @Override public boolean eat ( String typeOfFeed ) { if ( typeOfFeed . equals ( \"meat\" )) { return true ; } else { return false ; } } @Override public int getNumberOfLegs () { return super . numberOfLegs ; } } Main.java ... Animal cat = new Cat (); Animal dog = new Dog (); System . out . println ( cat . speak ()); System . out . println ( dog . speak ()); ... Preguntas propuestas a) \u00bfEs correcto el uso de herencia en la implementaci\u00f3n de las clases \"Cat\" y \"Dog\"?. \u00bfQu\u00e9 beneficios se obtiene?. b) En el caso de que no sea correcto, proponga una soluci\u00f3n alternativa. \u00bfCu\u00e1les son los beneficios de la soluci\u00f3n propuesta frente a la original?. Referencias [1] Blog Herencia vs Composici\u00f3n \u00bfTienes claro cu\u00e1l es el rival m\u00e1s d\u00e9bil?. [2] Libro Effective Java: A programming Language Guide.","title":"Pr\u00e1ctica 1"},{"location":"oop-p1/#practica-1-herencia-composicion-y-polimorfismo","text":"","title":"Pr\u00e1ctica 1: Herencia, composici\u00f3n y polimorfismo"},{"location":"oop-p1/#repaso-de-conceptos-teoricos","text":"","title":"Repaso de conceptos te\u00f3ricos"},{"location":"oop-p1/#herencia","text":"","title":"Herencia"},{"location":"oop-p1/#definicion","text":"Se puede definir la herencia como el mecanismo por el cual una clase permite heredar sus caracter\u00edsticas (atributos y m\u00e9todos) a otra clase. Este mecanismo puede ser usado para la reutilizaci\u00f3n de c\u00f3digo, la cual permite realizar extensiones independientes del software original. por Carlos Villag\u00f3mez, Enciclopedia de Programaci\u00f3n Orientada a Objetos En el ejemplo de la imagen anterior existe una jerarqu\u00eda de herencia de tres niveles en los que: Todas las clases heredan las funciones y propiedades de la clase \"Animal\". La clase \"Conejo\" hereda las funciones y propiedades de la clase \"Herb\u00edvoro\", las clases \"Le\u00f3n\" y \"Hiena\" las de la clase \"Carn\u00edvoro\" y la clase \"Hombre\" las de la clase \"Omn\u00edvoro\".","title":"Definici\u00f3n"},{"location":"oop-p1/#cuando-utilizar-la-herencia","text":"La herencia debe ser utilizada cuando se cumplen al menos las siguientes condiciones: Existe una relaci\u00f3n \"es un/una\" entre las entidades . Por ejemplo: un le\u00f3n o una hiena son animales, pero un animal no tiene porque ser un le\u00f3n (puede ser cualquiera de las otras subclases). Esto es debido a que la relaci\u00f3n de herencia es unidireccional. Se conoce el 100% de los requisitos del software y \u00e9stos no van a cambiar . Si se conoce perfectamente los requisitos del software que se va a implementar y estos no van a cambiar, se puede deducir las relaciones de herencia que existir\u00e1n entre las clases desde el principio. No obstante, en cualquier otro caso puede ser costoso durante el desarrollo eliminar/mantener estas relaciones si los requisitos van evolucionando en otro sentido. Por ejemplo, esto suceder\u00eda dentro de un proyecto donde se aplica una metodolog\u00eda de desarrollo \u00e1gil.","title":"\u00bfCu\u00e1ndo utilizar la herencia?"},{"location":"oop-p1/#polimorfismo-en-la-herencia","text":"La herencia otorga la propiedad de polimorfismo, que significa que cualquiera de las subclases pueden adoptar la forma de la superclase. Esta es una de las principales ventajas de la herencia, ya que el polimorfismo permite la abstracci\u00f3n del objeto concreto y usar su superclase. Por ejemplo, podr\u00edamos tratar cualquier instancia de la clase \"Hombre\" o \"Le\u00f3n\" como una instancia de la clase \"Animal\", ya que han herendado todas sus funciones y propiedades. Pero no al contrario, ya que la clase \"Le\u00f3n\" podr\u00eda haber a\u00f1adido nuevas propiedades o funciones que no est\u00e9n disponibles en la clase \"Animal\".","title":"Polimorfismo en la herencia"},{"location":"oop-p1/#cuales-son-las-ventajas-de-la-herencia","text":"Las ventajas que nos propone el uso de la herencia son las siguientes: Permite reutilizar c\u00f3digo de una manera r\u00e1pida y sencilla. Permite el uso del polimorfismo con facilidad. Permite sobreescribir m\u00e9todos, adapt\u00e1ndolos a necesidades espec\u00edficas. Permite crear clases abstractas que hacen de plantilla a las subclases (parecido al patr\u00f3n de dise\u00f1o \"Template Method\").","title":"\u00bfCu\u00e1les son las ventajas de la herencia?"},{"location":"oop-p1/#composicion","text":"","title":"Composici\u00f3n"},{"location":"oop-p1/#definicion_1","text":"La composici\u00f3n se basa en la creaci\u00f3n de clases que realizar\u00e1n una \u00fanica y espec\u00edfica funci\u00f3n que complementaran a otras clases, las cuales estar\u00e1n compuestas por ellas. Este mecanismo, nos permitir\u00e1 delegar las funciones a aquellas clases que se han implementado \u00fanicamente para cubrirlas, reutilizando su c\u00f3digo fuente donde sea necesario. por Arturo Verbel de Le\u00f3n, Diagrama de clases para dummies En el ejemplo anterior se puede observar: La clase \"Empresa\" esta compuesta por instancias de la clase \"Empleado\". La clase \"Empleado\" es el compuesto de la clase \"Empresa\", de hecho se establece una relaci\u00f3n donde la cardinalidad es 1..N por lo que la clase \"Empresa\" en su implementaci\u00f3n mantendr\u00e1 una lista de instancias de la clase \"Empleado\".","title":"Definici\u00f3n"},{"location":"oop-p1/#cuando-utilizar-la-composicion","text":"La composici\u00f3n debe ser utilizada cuando se cumplen al menos las siguientes condiciones: No existe una relaci\u00f3n \"es un/una\" entre las entidades, si no \"tiene\" . Por ejemplo: a una persona que le encanta correr se le podr\u00eda clasificar como \"runner\", pero establecerlo como herencia ser\u00eda un error, ya que la persona con el paso del tiempo podr\u00eda dejar de serlo. En este caso, ser\u00eda m\u00e1s correcto decir que tiene el \"rol\" de runner usando la composici\u00f3n, pudi\u00e9ndolo eliminar cuando fuese necesario. No se conocen 100% los requisitos del software y \u00e9stos ser\u00e1n actualizados . Cuando no se conocen por completo los requisitos del sistema es m\u00e1s correcto no establecer relaciones de herencia que pudiesen ser eliminadas posteriormente. Por este motivo, crear clases con las funciones espec\u00edficas y vincularlas a otras haciendo uso de la composici\u00f3n, proporciona mayor flexibilidad y tolerancia a cambios en la implementaci\u00f3n. Adem\u00e1s, permite modularizar el sistemma de forma de que sea posteriormente m\u00e1s facil de mantener.","title":"\u00bfCu\u00e1ndo utilizar la composici\u00f3n?"},{"location":"oop-p1/#polimorfismo-en-la-composicion","text":"La composici\u00f3n por si misma no es polim\u00f3rfica, lo cual puede ser de sus mayores desventajas. No obstante, esto puede ser facilmente solventado con el uso de interfaces. De esta manera, los objetos compuestos implementar\u00e1n las interfaces que interese en cada situaci\u00f3n, consiguiendo a\u00f1adir/eliminar las funciones que implementan sin necesidad de afectar a la funcionalidad propuesta por otras clases. por Sergio Mart\u00ednez Rodr\u00edguez, Herencia vs Composici\u00f3n \u00bfTienes claro cu\u00e1l es el rival m\u00e1s d\u00e9bil? En el ejemplo anterior se puede observar: La clase \"MainActivity\" tiene una funcionalidad dada por un elemento que contiene de la clase \"NavigationDelegate\". Por otro lado, la forma de notificar al resto de clases de que proporciona la funcionalidad \"navigate()\" es implementando la interfaz \"NavigationInterface\". Cuando la clase \"MainActivity\" no deba proporcionar la funcionalidad \"navigate()\" \u00fanicamente debe dejar de implementar la interfaz \"NavigationInterface\" y eliminar la instancia de la clase \"NavigationDelegate\" o dejar de invocar a su funci\u00f3n \"navigate()\".","title":"Polimorfismo en la composici\u00f3n"},{"location":"oop-p1/#herencia-vs-composicion","text":"Como se ha comentado anteriormente, la herencia es un mecanismo muy potente para reutilizar c\u00f3digo fuente, pero no siempre es la mejor t\u00e9cnica para conseguir este objetivo. Ya que, si se usa la herencia de forma inapropiada se puede conseguir software poco seguro y robusto. Adem\u00e1s, el uso de herencia viola el principio de encapsulaci\u00f3n, ya que la subclase siempre depender\u00e1 de la implementaci\u00f3n de los m\u00e9todos en la superclase (a no ser que los sobreescriba), y \u00e9stos m\u00e9todos se actualizar\u00e1n en futuras versiones, con lo que se conseguir\u00e1 incertidumbre en la funcionalidad del c\u00f3digo fuente programado. A continuaci\u00f3n, se muestra una tabla que incluye las diferencias de uso entre la herencia y la composici\u00f3n en algunas de las etapas del desarrollo software y en otros aspectos de inter\u00e9s: por Sergio Mart\u00ednez Rodr\u00edguez, Herencia vs Composici\u00f3n \u00bfTienes claro cu\u00e1l es el rival m\u00e1s d\u00e9bil?","title":"Herencia vs composici\u00f3n"},{"location":"oop-p1/#ejercicios-propuestos","text":"","title":"Ejercicios propuestos"},{"location":"oop-p1/#ejercicio-1","text":"Dado los siguientes fragmentos de c\u00f3digo responder a las siguientes preguntas:","title":"Ejercicio 1"},{"location":"oop-p1/#elementssetjava","text":"public class ElementsSet < E > extends HashSet < E > { //Number of attempted elements insertions using the \"add\" method private int numberOfAddedElements = 0 ; public ElementsSet () {} @Override public boolean add ( E element ) { numberOfAddedElements ++ ; //Counting the element added return super . add ( element ); } @Override public boolean addAll ( Collection <? extends E > elements ) { numberOfAddedElements += elements . size (); //Counting the elements added return super . addAll ( elements ); } public int getNumberOfAddedElements () { return numberOfAddedElements ; } }","title":"ElementsSet.java"},{"location":"oop-p1/#mainjava","text":"... ElementsSet < String > set = new ElementsSet < String > (); set . addAll ( Arrays . asList ( \"One\" , \"Two\" , \"Three\" )); System . out . println ( set . getNumberOfAddedElements ()); ...","title":"Main.java"},{"location":"oop-p1/#preguntas-propuestas","text":"a) \u00bfEs el uso de herencia adecuado para la implementaci\u00f3n de la clase \"ElementsSet\"?, \u00bfqu\u00e9 salida muestra la funci\u00f3n \"System.out.println\" al invocar el m\u00e9todo \"getNumberOfAddedElements\", 3 o 6?. b) En el caso de que haya alg\u00fan problema en la implementaci\u00f3n anterior, proponga una soluci\u00f3n alternativa usando composici\u00f3n que resuelva el problema.","title":"Preguntas propuestas"},{"location":"oop-p1/#ejercicio-2","text":"Dado los siguientes fragmentos de c\u00f3digo responder a las siguientes preguntas:","title":"Ejercicio 2"},{"location":"oop-p1/#animaljava","text":"public abstract class Animal { //Number of legs the animal holds protected int numberOfLegs = 0 ; public abstract String speak (); public abstract boolean eat ( String typeOfFeed ); public abstract int getNumberOfLegs (); }","title":"Animal.java"},{"location":"oop-p1/#catjava","text":"public class Cat extends Animal { @Override public String speak () { return \"Meow\" ; } @Override public boolean eat ( String typeOfFeed ) { if ( typeOfFeed . equals ( \"fish\" )) { return true ; } else { return false ; } } @Override public int getNumberOfLegs () { return super . numberOfLegs ; } }","title":"Cat.java"},{"location":"oop-p1/#dogjava","text":"public class Dog extends Animal { @Override public String speak () { return \"Woof\" ; } @Override public boolean eat ( String typeOfFeed ) { if ( typeOfFeed . equals ( \"meat\" )) { return true ; } else { return false ; } } @Override public int getNumberOfLegs () { return super . numberOfLegs ; } }","title":"Dog.java"},{"location":"oop-p1/#mainjava_1","text":"... Animal cat = new Cat (); Animal dog = new Dog (); System . out . println ( cat . speak ()); System . out . println ( dog . speak ()); ...","title":"Main.java"},{"location":"oop-p1/#preguntas-propuestas_1","text":"a) \u00bfEs correcto el uso de herencia en la implementaci\u00f3n de las clases \"Cat\" y \"Dog\"?. \u00bfQu\u00e9 beneficios se obtiene?. b) En el caso de que no sea correcto, proponga una soluci\u00f3n alternativa. \u00bfCu\u00e1les son los beneficios de la soluci\u00f3n propuesta frente a la original?.","title":"Preguntas propuestas"},{"location":"oop-p1/#referencias","text":"[1] Blog Herencia vs Composici\u00f3n \u00bfTienes claro cu\u00e1l es el rival m\u00e1s d\u00e9bil?. [2] Libro Effective Java: A programming Language Guide.","title":"Referencias"},{"location":"oop-p2/","text":"Pr\u00e1ctica 2: Refactoring Repaso de conceptos te\u00f3ricos Refactoring Definici\u00f3n El proceso de refactoring es un proceso sistem\u00e1tico, en el cual se pretende cambiar la estructura del software implementado para hacerlo m\u00e1s f\u00e1cil de entender y m\u00e1s r\u00e1pido de modificar sin cambiar su comportamiento. Es decir, en este proceso se pretende mejorar la calidad del c\u00f3digo fuente sin crear nueva funcionalidad. Refactoring is a controlled technique for improving the design of an existing code base. Its essence is applying a series of small behavior-preserving transformations, each of which \"too small to be worth doing\". However the cumulative effect of each of these transformations is quite significant. By doing them in small steps you reduce the risk of introducing errors. You also avoid having the system broken while you are carrying out the restructuring \u2014 which allows you to gradually refactor a system over an extended period of time. -- Martin Fowler Por lo tanto, en el proceso de refactorizaci\u00f3n se deben realizar peque\u00f1as modificaciones, las cuales sean manejables y vayan incrementando gradualmente la limpieza de c\u00f3digo mientras se mantiene la funcionalidad del mismo. Conforme se realizan estos cambios, se comienza a transformar el c\u00f3digo inicial en un c\u00f3digo m\u00e1s simple, m\u00e1s f\u00e1cil de leer y m\u00e1s mantenible. No es una simple refactorizaci\u00f3n lo que realiza el cambio, si no el efecto acumulativo de muchos peque\u00f1os \"refactorings\" realizados hac\u00eda un s\u00f3lo objetivo. por Justin Albano, What Is Refactoring? Razones para refactorizar A continuaci\u00f3n, seg\u00fan [1] se listan las posibles razones que promueven la refactorizaci\u00f3n del c\u00f3digo: C\u00f3digo duplicado. Una funci\u00f3n es demasiado larga. Un bucle es demasiado largo o est\u00e1 demasiado anidado (demasiada complejidad). Una clase tiene poca cohesi\u00f3n. Una interfaz no proporciona un nivel consistente de abstracci\u00f3n. Una lista de par\u00e1metros tiene demasiados par\u00e1metros. Los cambios dentro de una clase tienden a afectar a otras clases. Las jerarqu\u00edas de herencia tienen que ser modificadas en paralelo (afecta a todas las subclases un mismo cambio). Los atributos que se utilizan por varias clases no est\u00e1n organizados en una clase (se repiten). Una funci\u00f3n utiliza m\u00e1s caracter\u00edsticas propuestas por otra clase que de su propia clase. Un tipo de datos primitivo esta sobrecargado. Una clase no tiene una finalidad clara (no aporta mucho). Un objeto intermediario no hace nada. Una funci\u00f3n tiene un nombre que no especifica de forma clara su objetivo. Los atributos de una clase son p\u00fablicos. Una subclase s\u00f3lo utiliza un porcentaje m\u00ednimo de las funciones que hereda. Se utilizan comentarios para explicar c\u00f3digo d\u00edficil de entender. Se usan variables globales. Una funci\u00f3n contiene c\u00f3digo que parece que ser\u00e1 necesario alg\u00fan d\u00eda pero en la actualidad no se utiliza. Resumen de posibles refactorizaciones Finalmente, a continuaci\u00f3n se incluye algunas de las posibles refactorizaciones propuestas en [1] . La aplicaci\u00f3n de estas t\u00e9cnicas de refactorizaci\u00f3n depender\u00e1 de si en el softare implementado se encuentran alguno/s de los problemas incluidos en la lista anterior: Refactorizaci\u00f3n en el uso de datos Reemplazar un n\u00famero utilizado directamente por una constante. Renombrar una variable para darle un nombre m\u00e1s claro o informativo. Convertir una variable que se usa en m\u00faltiples sitios en m\u00faltiples variables de \u00fanico uso. Usar una variable local para prop\u00f3sitos locales en lugar de un par\u00e1metro de una funci\u00f3n. Convertir el uso de datos primitivos en el uso de una clase. Convertir un array (de bajo nivel) en un objeto. Encapsular una colecci\u00f3n. Refactorizaci\u00f3n en la implementaci\u00f3n de sentencias/instrucciones Descomponer una expresi\u00f3n l\u00f3gica. Convertir una expresi\u00f3n l\u00f3gica compleja en una funci\u00f3n l\u00f3gica con un nombre correcto para su definici\u00f3n. Unificar fragmentos de c\u00f3digo duplicado en diferentes partes de una expresi\u00f3n condicional. Eliminar el uso de \"break\" o \"return\" en lugar del uso de variables de control en los bucles. Devolver lo m\u00e1s r\u00e1pido posible la soluci\u00f3n en lugar de asignar el valor a una variable dentro de instrucciones if-else. Reemplazar condicionales (especialmente las sentencias \"case\") por el uso de polimorfismo. Refactorizaci\u00f3n en la implementaci\u00f3n de funciones Extraer una funci\u00f3n desde c\u00f3digo que se repite en varios lugares. Convertir una funci\u00f3n demasiado larga en una clase. Sustituir un algoritmo complejo por uno simple. Combinar funciones similares en una \u00fanica. Pasar el objeto completo en lugar de seleccionar algunos campos espec\u00edficos (en el caso de que sean muchos). Pasar algunos campos espec\u00edficos en lugar del objeto completo (en el caso de que sean pocos campos los utilizados). Refactorizaci\u00f3n en la implementaci\u00f3n de clases/interfaces Extraer c\u00f3digo especializado en subclases. Combinar c\u00f3digo similar en superclases. Mover una funci\u00f3n a otra clase en la que tenga m\u00e1s utilidad. Convertir una clase demasiado larga en dos. Eliminar una clase sin utilidad. Reemplazar herencia por composici\u00f3n (en el caso de que sea necesario). Unificar una superclase y una subclase si su implementaci\u00f3n es muy similar. Refactorizaci\u00f3n a nivel de sistema Cambiar la asociaci\u00f3n unidireccional de clases a bidireccional (en caso de que sea necesario). Cambiar la asociaci\u00f3n bidireccional de clases a unidireccional (en caso de que sea necesario). Proveer de una factoria para crear los objetos en lugar de usar un constructor simple. Reemplazar los c\u00f3digos de error con excepciones (en caso de que sea necesario). Ejercicios propuestos Ejercicio 1 Dado los siguientes fragmentos de c\u00f3digo responder a las siguientes preguntas: GroupOfUsers.java public class GroupOfUsers { private static Map < String , Integer > usersWithPoints = new HashMap < String , Integer > () {{ put ( \"User1\" , 800 ); put ( \"User2\" , 550 ); put ( \"User3\" , 20 ); put ( \"User4\" , 300 ); }}; public List < String > getUsers () { List < String > users = new ArrayList < String > (); //Sorting users by points usersWithPoints . entrySet () . stream () . sorted ( Map . Entry . < String , Integer > comparingByValue (). reversed ()) . forEachOrdered ( x -> users . add ( x . getKey ())); //Capitalizing the names of the users List < String > usersCapitalized = new ArrayList < String > (); users . forEach ( x -> usersCapitalized . add ( x . toUpperCase ())); return usersCapitalized ; } } Main.java ... GroupOfUsers group = new GroupOfUsers (); List < String > users = group . getUsers (); System . out . println ( \"The users are: \" + users ); ... Preguntas propuestas a) \u00bfExiste alg\u00fan tipo de problema en la implementaci\u00f3n anterior?, \u00bfes necesario aplicar refactoring en este caso?. En el caso de que existan problemas, detalle cu\u00e1les son y qu\u00e9 tipos de problemas generar\u00edan en el futuro si no se aplica el refactoring ahora. b) En el caso de la implementaci\u00f3n necesite la aplicaci\u00f3n de refactoring, realice los cambios oportunos e indique las mejoras que aporta su implementaci\u00f3n respecto a la original. Ejercicio 2 Dado los siguientes fragmentos de c\u00f3digo responder a las siguientes preguntas: GroupOfUsers.java public class GroupOfUsers { private static Map < String , Integer > usersWithPoints_Group1 = new HashMap < String , Integer > () {{ put ( \"User1\" , 800 ); put ( \"User2\" , 550 ); put ( \"User3\" , 20 ); put ( \"User4\" , 300 ); }}; private static Map < String , Integer > usersWithPoints_Group2 = new HashMap < String , Integer > () {{ put ( \"User1\" , 10 ); put ( \"User2\" , 990 ); put ( \"User3\" , 760 ); put ( \"User4\" , 230 ); }}; private static Map < String , Integer > usersWithPoints_Group3 = new HashMap < String , Integer > () {{ put ( \"User1\" , 1000 ); put ( \"User2\" , 200 ); put ( \"User3\" , 5 ); put ( \"User4\" , 780 ); }}; public List < ArrayList < String >> getUsers () { List < String > users1 = new ArrayList < String > (); List < String > users2 = new ArrayList < String > (); List < String > users3 = new ArrayList < String > (); List < ArrayList < String >> users = new ArrayList < ArrayList < String >> (); //Sorting users by points usersWithPoints_Group1 . entrySet () . stream () . sorted ( Map . Entry . < String , Integer > comparingByValue (). reversed ()) . forEachOrdered ( x -> users1 . add ( x . getKey ())); usersWithPoints_Group2 . entrySet () . stream () . sorted ( Map . Entry . < String , Integer > comparingByValue (). reversed ()) . forEachOrdered ( x -> users2 . add ( x . getKey ())); usersWithPoints_Group3 . entrySet () . stream () . sorted ( Map . Entry . < String , Integer > comparingByValue (). reversed ()) . forEachOrdered ( x -> users3 . add ( x . getKey ())); //Capitalizing the names of the users List < String > usersCapitalized1 = new ArrayList < String > (); List < String > usersCapitalized2 = new ArrayList < String > (); List < String > usersCapitalized3 = new ArrayList < String > (); users1 . forEach ( x -> usersCapitalized1 . add ( x . toUpperCase ())); users2 . forEach ( x -> usersCapitalized2 . add ( x . toUpperCase ())); users3 . forEach ( x -> usersCapitalized3 . add ( x . toUpperCase ())); //Adding users to the main list users . add (( ArrayList < String > ) usersCapitalized1 ); users . add (( ArrayList < String > ) usersCapitalized2 ); users . add (( ArrayList < String > ) usersCapitalized3 ); return users ; } } Main.java ... GroupOfUsers group = new GroupOfUsers (); List < ArrayList < String >> users = group . getUsers (); System . out . println ( \"The users are: \" + users ); ... Preguntas propuestas a) El software del ejercicio anterior ha evolucionado a\u00f1adiendo nueva funcionalidad en su implementaci\u00f3n. \u00bfExiste alg\u00fan tipo de problema en esta versi\u00f3n de la implementaci\u00f3n?, \u00bfes necesario aplicar refactoring en este caso?. En el caso de que existan problemas, detalle cu\u00e1les son y qu\u00e9 tipos de problemas generar\u00edan en el futuro si no se aplica el refactoring ahora. b) En el caso de la implementaci\u00f3n necesite la aplicaci\u00f3n de refactoring, realice los cambios oportunos e indique las mejoras que aporta su implementaci\u00f3n respecto a la original. Referencias [1] Libro Code Complete: A Practical Handbook of Software Construction, Second Edition. [2] Blog What Is Refactoring.","title":"Pr\u00e1ctica 2"},{"location":"oop-p2/#practica-2-refactoring","text":"","title":"Pr\u00e1ctica 2: Refactoring"},{"location":"oop-p2/#repaso-de-conceptos-teoricos","text":"","title":"Repaso de conceptos te\u00f3ricos"},{"location":"oop-p2/#refactoring","text":"","title":"Refactoring"},{"location":"oop-p2/#definicion","text":"El proceso de refactoring es un proceso sistem\u00e1tico, en el cual se pretende cambiar la estructura del software implementado para hacerlo m\u00e1s f\u00e1cil de entender y m\u00e1s r\u00e1pido de modificar sin cambiar su comportamiento. Es decir, en este proceso se pretende mejorar la calidad del c\u00f3digo fuente sin crear nueva funcionalidad. Refactoring is a controlled technique for improving the design of an existing code base. Its essence is applying a series of small behavior-preserving transformations, each of which \"too small to be worth doing\". However the cumulative effect of each of these transformations is quite significant. By doing them in small steps you reduce the risk of introducing errors. You also avoid having the system broken while you are carrying out the restructuring \u2014 which allows you to gradually refactor a system over an extended period of time. -- Martin Fowler Por lo tanto, en el proceso de refactorizaci\u00f3n se deben realizar peque\u00f1as modificaciones, las cuales sean manejables y vayan incrementando gradualmente la limpieza de c\u00f3digo mientras se mantiene la funcionalidad del mismo. Conforme se realizan estos cambios, se comienza a transformar el c\u00f3digo inicial en un c\u00f3digo m\u00e1s simple, m\u00e1s f\u00e1cil de leer y m\u00e1s mantenible. No es una simple refactorizaci\u00f3n lo que realiza el cambio, si no el efecto acumulativo de muchos peque\u00f1os \"refactorings\" realizados hac\u00eda un s\u00f3lo objetivo. por Justin Albano, What Is Refactoring?","title":"Definici\u00f3n"},{"location":"oop-p2/#razones-para-refactorizar","text":"A continuaci\u00f3n, seg\u00fan [1] se listan las posibles razones que promueven la refactorizaci\u00f3n del c\u00f3digo: C\u00f3digo duplicado. Una funci\u00f3n es demasiado larga. Un bucle es demasiado largo o est\u00e1 demasiado anidado (demasiada complejidad). Una clase tiene poca cohesi\u00f3n. Una interfaz no proporciona un nivel consistente de abstracci\u00f3n. Una lista de par\u00e1metros tiene demasiados par\u00e1metros. Los cambios dentro de una clase tienden a afectar a otras clases. Las jerarqu\u00edas de herencia tienen que ser modificadas en paralelo (afecta a todas las subclases un mismo cambio). Los atributos que se utilizan por varias clases no est\u00e1n organizados en una clase (se repiten). Una funci\u00f3n utiliza m\u00e1s caracter\u00edsticas propuestas por otra clase que de su propia clase. Un tipo de datos primitivo esta sobrecargado. Una clase no tiene una finalidad clara (no aporta mucho). Un objeto intermediario no hace nada. Una funci\u00f3n tiene un nombre que no especifica de forma clara su objetivo. Los atributos de una clase son p\u00fablicos. Una subclase s\u00f3lo utiliza un porcentaje m\u00ednimo de las funciones que hereda. Se utilizan comentarios para explicar c\u00f3digo d\u00edficil de entender. Se usan variables globales. Una funci\u00f3n contiene c\u00f3digo que parece que ser\u00e1 necesario alg\u00fan d\u00eda pero en la actualidad no se utiliza.","title":"Razones para refactorizar"},{"location":"oop-p2/#resumen-de-posibles-refactorizaciones","text":"Finalmente, a continuaci\u00f3n se incluye algunas de las posibles refactorizaciones propuestas en [1] . La aplicaci\u00f3n de estas t\u00e9cnicas de refactorizaci\u00f3n depender\u00e1 de si en el softare implementado se encuentran alguno/s de los problemas incluidos en la lista anterior:","title":"Resumen de posibles refactorizaciones"},{"location":"oop-p2/#refactorizacion-en-el-uso-de-datos","text":"Reemplazar un n\u00famero utilizado directamente por una constante. Renombrar una variable para darle un nombre m\u00e1s claro o informativo. Convertir una variable que se usa en m\u00faltiples sitios en m\u00faltiples variables de \u00fanico uso. Usar una variable local para prop\u00f3sitos locales en lugar de un par\u00e1metro de una funci\u00f3n. Convertir el uso de datos primitivos en el uso de una clase. Convertir un array (de bajo nivel) en un objeto. Encapsular una colecci\u00f3n.","title":"Refactorizaci\u00f3n en el uso de datos"},{"location":"oop-p2/#refactorizacion-en-la-implementacion-de-sentenciasinstrucciones","text":"Descomponer una expresi\u00f3n l\u00f3gica. Convertir una expresi\u00f3n l\u00f3gica compleja en una funci\u00f3n l\u00f3gica con un nombre correcto para su definici\u00f3n. Unificar fragmentos de c\u00f3digo duplicado en diferentes partes de una expresi\u00f3n condicional. Eliminar el uso de \"break\" o \"return\" en lugar del uso de variables de control en los bucles. Devolver lo m\u00e1s r\u00e1pido posible la soluci\u00f3n en lugar de asignar el valor a una variable dentro de instrucciones if-else. Reemplazar condicionales (especialmente las sentencias \"case\") por el uso de polimorfismo.","title":"Refactorizaci\u00f3n en la implementaci\u00f3n de sentencias/instrucciones"},{"location":"oop-p2/#refactorizacion-en-la-implementacion-de-funciones","text":"Extraer una funci\u00f3n desde c\u00f3digo que se repite en varios lugares. Convertir una funci\u00f3n demasiado larga en una clase. Sustituir un algoritmo complejo por uno simple. Combinar funciones similares en una \u00fanica. Pasar el objeto completo en lugar de seleccionar algunos campos espec\u00edficos (en el caso de que sean muchos). Pasar algunos campos espec\u00edficos en lugar del objeto completo (en el caso de que sean pocos campos los utilizados).","title":"Refactorizaci\u00f3n en la implementaci\u00f3n de funciones"},{"location":"oop-p2/#refactorizacion-en-la-implementacion-de-clasesinterfaces","text":"Extraer c\u00f3digo especializado en subclases. Combinar c\u00f3digo similar en superclases. Mover una funci\u00f3n a otra clase en la que tenga m\u00e1s utilidad. Convertir una clase demasiado larga en dos. Eliminar una clase sin utilidad. Reemplazar herencia por composici\u00f3n (en el caso de que sea necesario). Unificar una superclase y una subclase si su implementaci\u00f3n es muy similar.","title":"Refactorizaci\u00f3n en la implementaci\u00f3n de clases/interfaces"},{"location":"oop-p2/#refactorizacion-a-nivel-de-sistema","text":"Cambiar la asociaci\u00f3n unidireccional de clases a bidireccional (en caso de que sea necesario). Cambiar la asociaci\u00f3n bidireccional de clases a unidireccional (en caso de que sea necesario). Proveer de una factoria para crear los objetos en lugar de usar un constructor simple. Reemplazar los c\u00f3digos de error con excepciones (en caso de que sea necesario).","title":"Refactorizaci\u00f3n a nivel de sistema"},{"location":"oop-p2/#ejercicios-propuestos","text":"","title":"Ejercicios propuestos"},{"location":"oop-p2/#ejercicio-1","text":"Dado los siguientes fragmentos de c\u00f3digo responder a las siguientes preguntas:","title":"Ejercicio 1"},{"location":"oop-p2/#groupofusersjava","text":"public class GroupOfUsers { private static Map < String , Integer > usersWithPoints = new HashMap < String , Integer > () {{ put ( \"User1\" , 800 ); put ( \"User2\" , 550 ); put ( \"User3\" , 20 ); put ( \"User4\" , 300 ); }}; public List < String > getUsers () { List < String > users = new ArrayList < String > (); //Sorting users by points usersWithPoints . entrySet () . stream () . sorted ( Map . Entry . < String , Integer > comparingByValue (). reversed ()) . forEachOrdered ( x -> users . add ( x . getKey ())); //Capitalizing the names of the users List < String > usersCapitalized = new ArrayList < String > (); users . forEach ( x -> usersCapitalized . add ( x . toUpperCase ())); return usersCapitalized ; } }","title":"GroupOfUsers.java"},{"location":"oop-p2/#mainjava","text":"... GroupOfUsers group = new GroupOfUsers (); List < String > users = group . getUsers (); System . out . println ( \"The users are: \" + users ); ...","title":"Main.java"},{"location":"oop-p2/#preguntas-propuestas","text":"a) \u00bfExiste alg\u00fan tipo de problema en la implementaci\u00f3n anterior?, \u00bfes necesario aplicar refactoring en este caso?. En el caso de que existan problemas, detalle cu\u00e1les son y qu\u00e9 tipos de problemas generar\u00edan en el futuro si no se aplica el refactoring ahora. b) En el caso de la implementaci\u00f3n necesite la aplicaci\u00f3n de refactoring, realice los cambios oportunos e indique las mejoras que aporta su implementaci\u00f3n respecto a la original.","title":"Preguntas propuestas"},{"location":"oop-p2/#ejercicio-2","text":"Dado los siguientes fragmentos de c\u00f3digo responder a las siguientes preguntas:","title":"Ejercicio 2"},{"location":"oop-p2/#groupofusersjava_1","text":"public class GroupOfUsers { private static Map < String , Integer > usersWithPoints_Group1 = new HashMap < String , Integer > () {{ put ( \"User1\" , 800 ); put ( \"User2\" , 550 ); put ( \"User3\" , 20 ); put ( \"User4\" , 300 ); }}; private static Map < String , Integer > usersWithPoints_Group2 = new HashMap < String , Integer > () {{ put ( \"User1\" , 10 ); put ( \"User2\" , 990 ); put ( \"User3\" , 760 ); put ( \"User4\" , 230 ); }}; private static Map < String , Integer > usersWithPoints_Group3 = new HashMap < String , Integer > () {{ put ( \"User1\" , 1000 ); put ( \"User2\" , 200 ); put ( \"User3\" , 5 ); put ( \"User4\" , 780 ); }}; public List < ArrayList < String >> getUsers () { List < String > users1 = new ArrayList < String > (); List < String > users2 = new ArrayList < String > (); List < String > users3 = new ArrayList < String > (); List < ArrayList < String >> users = new ArrayList < ArrayList < String >> (); //Sorting users by points usersWithPoints_Group1 . entrySet () . stream () . sorted ( Map . Entry . < String , Integer > comparingByValue (). reversed ()) . forEachOrdered ( x -> users1 . add ( x . getKey ())); usersWithPoints_Group2 . entrySet () . stream () . sorted ( Map . Entry . < String , Integer > comparingByValue (). reversed ()) . forEachOrdered ( x -> users2 . add ( x . getKey ())); usersWithPoints_Group3 . entrySet () . stream () . sorted ( Map . Entry . < String , Integer > comparingByValue (). reversed ()) . forEachOrdered ( x -> users3 . add ( x . getKey ())); //Capitalizing the names of the users List < String > usersCapitalized1 = new ArrayList < String > (); List < String > usersCapitalized2 = new ArrayList < String > (); List < String > usersCapitalized3 = new ArrayList < String > (); users1 . forEach ( x -> usersCapitalized1 . add ( x . toUpperCase ())); users2 . forEach ( x -> usersCapitalized2 . add ( x . toUpperCase ())); users3 . forEach ( x -> usersCapitalized3 . add ( x . toUpperCase ())); //Adding users to the main list users . add (( ArrayList < String > ) usersCapitalized1 ); users . add (( ArrayList < String > ) usersCapitalized2 ); users . add (( ArrayList < String > ) usersCapitalized3 ); return users ; } }","title":"GroupOfUsers.java"},{"location":"oop-p2/#mainjava_1","text":"... GroupOfUsers group = new GroupOfUsers (); List < ArrayList < String >> users = group . getUsers (); System . out . println ( \"The users are: \" + users ); ...","title":"Main.java"},{"location":"oop-p2/#preguntas-propuestas_1","text":"a) El software del ejercicio anterior ha evolucionado a\u00f1adiendo nueva funcionalidad en su implementaci\u00f3n. \u00bfExiste alg\u00fan tipo de problema en esta versi\u00f3n de la implementaci\u00f3n?, \u00bfes necesario aplicar refactoring en este caso?. En el caso de que existan problemas, detalle cu\u00e1les son y qu\u00e9 tipos de problemas generar\u00edan en el futuro si no se aplica el refactoring ahora. b) En el caso de la implementaci\u00f3n necesite la aplicaci\u00f3n de refactoring, realice los cambios oportunos e indique las mejoras que aporta su implementaci\u00f3n respecto a la original.","title":"Preguntas propuestas"},{"location":"oop-p2/#referencias","text":"[1] Libro Code Complete: A Practical Handbook of Software Construction, Second Edition. [2] Blog What Is Refactoring.","title":"Referencias"},{"location":"oop-p3/","text":"Pr\u00e1ctica 3 TO DO","title":"Pr\u00e1ctica 3"},{"location":"oop-p3/#practica-3","text":"","title":"Pr\u00e1ctica 3"},{"location":"oop-p3/#to-do","text":"","title":"TO DO"},{"location":"oop-p4/","text":"Pr\u00e1ctica 4 TO DO","title":"Pr\u00e1ctica 4"},{"location":"oop-p4/#practica-4","text":"","title":"Pr\u00e1ctica 4"},{"location":"oop-p4/#to-do","text":"","title":"TO DO"}]}