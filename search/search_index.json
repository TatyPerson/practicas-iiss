{"config":{"lang":["en"],"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Pr\u00e1ticas de Implementaci\u00f3n e Implantaci\u00f3n de Sistemas Software Programaci\u00f3n orientada a objetos Pr\u00e1ctica 1 Pr\u00e1ctica 2 Pr\u00e1ctica 3 Pr\u00e1ctica 4 Programaci\u00f3n funcional Pr\u00e1ctica 1 Pr\u00e1ctica 2 Programaci\u00f3n dirigida por eventos Pr\u00e1ctica 1 Pr\u00e1ctica 2 Pr\u00e1ctica 3","title":"Home"},{"location":"#praticas-de-implementacion-e-implantacion-de-sistemas-software","text":"","title":"Pr\u00e1ticas de Implementaci\u00f3n e Implantaci\u00f3n de Sistemas Software"},{"location":"#programacion-orientada-a-objetos","text":"Pr\u00e1ctica 1 Pr\u00e1ctica 2 Pr\u00e1ctica 3 Pr\u00e1ctica 4","title":"Programaci\u00f3n orientada a objetos"},{"location":"#programacion-funcional","text":"Pr\u00e1ctica 1 Pr\u00e1ctica 2","title":"Programaci\u00f3n funcional"},{"location":"#programacion-dirigida-por-eventos","text":"Pr\u00e1ctica 1 Pr\u00e1ctica 2 Pr\u00e1ctica 3","title":"Programaci\u00f3n dirigida por eventos"},{"location":"ep-p1/","text":"Pr\u00e1ctica 1 TO DO","title":"Pr\u00e1ctica 1"},{"location":"ep-p1/#practica-1","text":"","title":"Pr\u00e1ctica 1"},{"location":"ep-p1/#to-do","text":"","title":"TO DO"},{"location":"ep-p2/","text":"Pr\u00e1ctica 2 TO DO","title":"Pr\u00e1ctica 2"},{"location":"ep-p2/#practica-2","text":"","title":"Pr\u00e1ctica 2"},{"location":"ep-p2/#to-do","text":"","title":"TO DO"},{"location":"ep-p3/","text":"Pr\u00e1ctica 3 TO DO","title":"Pr\u00e1ctica 3"},{"location":"ep-p3/#practica-3","text":"","title":"Pr\u00e1ctica 3"},{"location":"ep-p3/#to-do","text":"","title":"TO DO"},{"location":"fp-p1/","text":"Pr\u00e1ctica 1 TO DO","title":"Pr\u00e1ctica 1"},{"location":"fp-p1/#practica-1","text":"","title":"Pr\u00e1ctica 1"},{"location":"fp-p1/#to-do","text":"","title":"TO DO"},{"location":"fp-p2/","text":"Pr\u00e1ctica 2 TO DO","title":"Pr\u00e1ctica 2"},{"location":"fp-p2/#practica-2","text":"","title":"Pr\u00e1ctica 2"},{"location":"fp-p2/#to-do","text":"","title":"TO DO"},{"location":"oop-p1/","text":"Pr\u00e1ctica 1: Herencia, composici\u00f3n y polimorfismo Repaso de conceptos te\u00f3ricos Herencia Definici\u00f3n Se puede definir la herencia como el mecanismo por el cual una clase permite heredar sus caracter\u00edsticas (atributos y m\u00e9todos) a otra clase. Este mecanismo puede ser usado para la reutilizaci\u00f3n de c\u00f3digo, la cual permite realizar extensiones independientes del software original. En el ejemplo de la imagen anterior existe una jerarqu\u00eda de herencia de tres niveles en los que: Todas las clases heredan las funciones y propiedades de la clase \"Animal\". La clase \"Conejo\" hereda las funciones y propiedades de la clase \"Herb\u00edvoro\", las clases \"Le\u00f3n\" y \"Hiena\" las de la clase \"Carn\u00edvoro\" y la clase \"Hombre\" las de la clase \"Omn\u00edvoro\". \u00bfCu\u00e1ndo utilizar la herencia? La herencia debe ser utilizada cuando se cumplen al menos las siguientes condiciones: Existe una relaci\u00f3n \"es un/una\" entre las entidades . Por ejemplo: un le\u00f3n o una hiena son animales, pero un animal no tiene porque ser un le\u00f3n (puede ser cualquiera de las otras subclases). Esto es debido a que la relaci\u00f3n de herencia es unidireccional. Se conoce el 100% de los requisitos del software y \u00e9stos no van a cambiar . Si se conoce perfectamente los requisitos del software que se va a implementar y estos no van a cambiar, se puede deducir las relaciones de herencia que existir\u00e1n entre las clases desde el principio. No obstante, en cualquier otro caso puede ser costoso durante el desarrollo eliminar/mantener estas relaciones si los requisitos van evolucionando en otro sentido. Por ejemplo, esto suceder\u00eda dentro de un proyecto donde se aplica una metodolog\u00eda de desarrollo \u00e1gil. Polimorfismo en la herencia La herencia otorga la propiedad de polimorfismo, que significa que cualquiera de las subclases pueden adoptar la forma de la superclase. Esta es una de las principales ventajas de la herencia, ya que el polimorfismo permite la abstracci\u00f3n del objeto concreto y usar su superclase. Por ejemplo, podr\u00edamos tratar cualquier instancia de la clase \"Hombre\" o \"Le\u00f3n\" como una instancia de la clase \"Animal\", ya que han herendado todas sus funciones y propiedades. Pero no al contrario, ya que la clase \"Le\u00f3n\" podr\u00eda haber a\u00f1adido nuevas propiedades o funciones que no est\u00e9n disponibles en la clase \"Animal\". \u00bfCu\u00e1les son las ventajas de la herencia? Las ventajas que nos propone el uso de la herencia son las siguientes: Permite reutilizar c\u00f3digo de una manera r\u00e1pida y sencilla. Permite el uso del polimorfismo con facilidad. Permite sobreescribir m\u00e9todos, adapt\u00e1ndolos a necesidades espec\u00edficas. Permite crear clases abstractas que hacen de plantilla a las subclases (parecido al patr\u00f3n de dise\u00f1o \"Template Method\"). Composici\u00f3n Definici\u00f3n La composici\u00f3n se basa en la creaci\u00f3n de clases que realizar\u00e1n una \u00fanica y espec\u00edfica funci\u00f3n que complementaran a otras clases, las cuales estar\u00e1n compuestas por ellas. Este mecanismo, nos permitir\u00e1 delegar las funciones a aquellas clases que se han implementado \u00fanicamente para cubrirlas, reutilizando su c\u00f3digo fuente donde sea necesario. En el ejemplo anterior se puede observar: La clase \"Empresa\" esta compuesta por instancias de la clase \"Empleado\". La clase \"Empleado\" es el compuesto de la clase \"Empresa\", de hecho se establece una relaci\u00f3n donde la cardinalidad es 1..N por lo que la clase \"Empresa\" en su implementaci\u00f3n mantendr\u00e1 una lista de instancias de la clase \"Empleado\". \u00bfCu\u00e1ndo utilizar la composici\u00f3n? La composici\u00f3n debe ser utilizada cuando se cumplen al menos las siguientes condiciones: No existe una relaci\u00f3n \"es un/una\" entre las entidades, si no \"tiene\" . Por ejemplo: a una persona que le encanta correr se le podr\u00eda clasificar como \"runner\", pero establecerlo como herencia ser\u00eda un error, ya que la persona con el paso del tiempo podr\u00eda dejar de serlo. En este caso, ser\u00eda m\u00e1s correcto decir que tiene el \"rol\" de runner usando la composici\u00f3n, pudi\u00e9ndolo eliminar cuando fuese necesario. No se conocen 100% los requisitos del software y \u00e9stos ser\u00e1n actualizados . Cuando no se conocen por completo los requisitos del sistema es m\u00e1s correcto no establecer relaciones de herencia que pudiesen ser eliminadas posteriormente. Por este motivo, crear clases con las funciones espec\u00edficas y vincularlas a otras haciendo uso de la composici\u00f3n, proporciona mayor flexibilidad y tolerancia a cambios en la implementaci\u00f3n. Adem\u00e1s, permite modularizar el sistemma de forma de que sea posteriormente m\u00e1s facil de mantener. Polimorfismo en la composici\u00f3n La composici\u00f3n por si misma no es polim\u00f3rfica, lo cual puede ser de sus mayores desventajas. No obstante, esto puede ser facilmente solventado con el uso de interfaces. De esta manera, los objetos compuestos implementar\u00e1n las interfaces que interese en cada situaci\u00f3n, consiguiendo a\u00f1adir/eliminar las funciones que implementan sin necesidad de afectar a la funcionalidad propuesta por otras clases. En el ejemplo anterior se puede observar: La clase \"MainActivity\" tiene una funcionalidad dada por un elemento que contiene de la clase \"NavigationDelegate\". Por otro lado, la forma de notificar al resto de clases de que proporciona la funcionalidad \"navigate()\" es implementando la interfaz \"NavigationInterface\". Cuando la clase \"MainActivity\" no deba proporcionar la funcionalidad \"navigate()\" \u00fanicamente debe dejar de implementar la interfaz \"NavigationInterface\" y eliminar la instancia de la clase \"NavigationDelegate\" o dejar de invocar a su funci\u00f3n \"navigate()\". Herencia vs composici\u00f3n Como se ha comentado anteriormente, la herencia es un mecanismo muy potente para reutilizar c\u00f3digo fuente, pero no siempre es la mejor t\u00e9cnica para conseguir este objetivo. Ya que, si se usa la herencia de forma inapropiada se puede conseguir software poco seguro y robusto. Adem\u00e1s, el uso de herencia viola el principio de encapsulaci\u00f3n, ya que la subclase siempre depender\u00e1 de la implementaci\u00f3n de los m\u00e9todos en la superclase (a no ser que los sobreescriba), y \u00e9stos m\u00e9todos se actualizar\u00e1n en futuras versiones, con lo que se conseguir\u00e1 incertidumbre en la funcionalidad del c\u00f3digo fuente programado. A continuaci\u00f3n, se muestra una tabla que incluye las diferencias de uso entre la herencia y la composici\u00f3n en algunas de las etapas del desarrollo software y en otros aspectos de inter\u00e9s: Ejercicios propuestos Ejercicio 1 Dado los siguientes fragmentos de c\u00f3digo responder a las siguientes preguntas: ElementsSet.java public class ElementsSet < E > extends HashSet < E > { //Number of attempted elements insertions using the \"add\" method private int numberOfAddedElements = 0 ; public ElementsSet () {} @Override public boolean add ( E element ) { numberOfAddedElements ++ ; //Counting the element added return super . add ( element ); } @Override public boolean addAll ( Collection <? extends E > elements ) { numberOfAddedElements += elements . size (); //Counting the elements added return super . addAll ( elements ); } public int getNumberOfAddedElements () { return numberOfAddedElements ; } } Main.java ... ElementsSet < String > set = new ElementsSet < String > (); set . addAll ( Arrays . asList ( \"One\" , \"Two\" , \"Three\" )); System . out . println ( set . getNumberOfAddedElements ()); ... Preguntas propuestas: a) \u00bfEs el uso de herencia adecuado para la implementaci\u00f3n de la clase \"ElementsSet\"?, \u00bfqu\u00e9 salida muestra la funci\u00f3n \"System.out.println\" al invocar el m\u00e9todo \"getNumberOfAddedElements\", 3 o 6?. b) En el caso de que haya alg\u00fan problema en la implementaci\u00f3n anterior, proponga una soluci\u00f3n alternativa usando composici\u00f3n que resuelva el problema. Ejercicio 2 Animal.java public abstract class Animal { //Number of legs the animal holds protected int numberOfLegs = 0 ; public abstract String speak (); public abstract boolean eat ( String typeOfFeed ); public abstract int getNumberOfLegs (); } Cat.java public class Cat extends Animal { @Override public String speak () { return \"Meow\" ; } @Override public boolean eat ( String typeOfFeed ) { if ( typeOfFeed . equals ( \"fish\" )) { return true ; } else { return false ; } } @Override public int getNumberOfLegs () { return super . numberOfLegs ; } } Dog.java public class Dog extends Animal { @Override public String speak () { return \"Woof\" ; } @Override public boolean eat ( String typeOfFeed ) { if ( typeOfFeed . equals ( \"meat\" )) { return true ; } else { return false ; } } @Override public int getNumberOfLegs () { return super . numberOfLegs ; } } Main.java ... Animal cat = new Cat (); Animal dog = new Dog (); System . out . println ( cat . speak ()); System . out . println ( dog . speak ()); ... Preguntas propuestas: a) \u00bfEs correcto el uso de herencia en la implementaci\u00f3n de las clases \"Cat\" y \"Dog\"?. \u00bfQu\u00e9 beneficios se obtiene?. b) En el caso de que no sea correcto, proponga una soluci\u00f3n alternativa. \u00bfCu\u00e1les son los beneficios de la soluci\u00f3n propuesta frente a la original?. Referencias [1] Blog sobre herencia vs composici\u00f3n. [2] Libro effective Java: A programming Language Guide.","title":"Pr\u00e1ctica 1"},{"location":"oop-p1/#practica-1-herencia-composicion-y-polimorfismo","text":"","title":"Pr\u00e1ctica 1: Herencia, composici\u00f3n y polimorfismo"},{"location":"oop-p1/#repaso-de-conceptos-teoricos","text":"","title":"Repaso de conceptos te\u00f3ricos"},{"location":"oop-p1/#herencia","text":"","title":"Herencia"},{"location":"oop-p1/#definicion","text":"Se puede definir la herencia como el mecanismo por el cual una clase permite heredar sus caracter\u00edsticas (atributos y m\u00e9todos) a otra clase. Este mecanismo puede ser usado para la reutilizaci\u00f3n de c\u00f3digo, la cual permite realizar extensiones independientes del software original. En el ejemplo de la imagen anterior existe una jerarqu\u00eda de herencia de tres niveles en los que: Todas las clases heredan las funciones y propiedades de la clase \"Animal\". La clase \"Conejo\" hereda las funciones y propiedades de la clase \"Herb\u00edvoro\", las clases \"Le\u00f3n\" y \"Hiena\" las de la clase \"Carn\u00edvoro\" y la clase \"Hombre\" las de la clase \"Omn\u00edvoro\".","title":"Definici\u00f3n"},{"location":"oop-p1/#cuando-utilizar-la-herencia","text":"La herencia debe ser utilizada cuando se cumplen al menos las siguientes condiciones: Existe una relaci\u00f3n \"es un/una\" entre las entidades . Por ejemplo: un le\u00f3n o una hiena son animales, pero un animal no tiene porque ser un le\u00f3n (puede ser cualquiera de las otras subclases). Esto es debido a que la relaci\u00f3n de herencia es unidireccional. Se conoce el 100% de los requisitos del software y \u00e9stos no van a cambiar . Si se conoce perfectamente los requisitos del software que se va a implementar y estos no van a cambiar, se puede deducir las relaciones de herencia que existir\u00e1n entre las clases desde el principio. No obstante, en cualquier otro caso puede ser costoso durante el desarrollo eliminar/mantener estas relaciones si los requisitos van evolucionando en otro sentido. Por ejemplo, esto suceder\u00eda dentro de un proyecto donde se aplica una metodolog\u00eda de desarrollo \u00e1gil.","title":"\u00bfCu\u00e1ndo utilizar la herencia?"},{"location":"oop-p1/#polimorfismo-en-la-herencia","text":"La herencia otorga la propiedad de polimorfismo, que significa que cualquiera de las subclases pueden adoptar la forma de la superclase. Esta es una de las principales ventajas de la herencia, ya que el polimorfismo permite la abstracci\u00f3n del objeto concreto y usar su superclase. Por ejemplo, podr\u00edamos tratar cualquier instancia de la clase \"Hombre\" o \"Le\u00f3n\" como una instancia de la clase \"Animal\", ya que han herendado todas sus funciones y propiedades. Pero no al contrario, ya que la clase \"Le\u00f3n\" podr\u00eda haber a\u00f1adido nuevas propiedades o funciones que no est\u00e9n disponibles en la clase \"Animal\".","title":"Polimorfismo en la herencia"},{"location":"oop-p1/#cuales-son-las-ventajas-de-la-herencia","text":"Las ventajas que nos propone el uso de la herencia son las siguientes: Permite reutilizar c\u00f3digo de una manera r\u00e1pida y sencilla. Permite el uso del polimorfismo con facilidad. Permite sobreescribir m\u00e9todos, adapt\u00e1ndolos a necesidades espec\u00edficas. Permite crear clases abstractas que hacen de plantilla a las subclases (parecido al patr\u00f3n de dise\u00f1o \"Template Method\").","title":"\u00bfCu\u00e1les son las ventajas de la herencia?"},{"location":"oop-p1/#composicion","text":"","title":"Composici\u00f3n"},{"location":"oop-p1/#definicion_1","text":"La composici\u00f3n se basa en la creaci\u00f3n de clases que realizar\u00e1n una \u00fanica y espec\u00edfica funci\u00f3n que complementaran a otras clases, las cuales estar\u00e1n compuestas por ellas. Este mecanismo, nos permitir\u00e1 delegar las funciones a aquellas clases que se han implementado \u00fanicamente para cubrirlas, reutilizando su c\u00f3digo fuente donde sea necesario. En el ejemplo anterior se puede observar: La clase \"Empresa\" esta compuesta por instancias de la clase \"Empleado\". La clase \"Empleado\" es el compuesto de la clase \"Empresa\", de hecho se establece una relaci\u00f3n donde la cardinalidad es 1..N por lo que la clase \"Empresa\" en su implementaci\u00f3n mantendr\u00e1 una lista de instancias de la clase \"Empleado\".","title":"Definici\u00f3n"},{"location":"oop-p1/#cuando-utilizar-la-composicion","text":"La composici\u00f3n debe ser utilizada cuando se cumplen al menos las siguientes condiciones: No existe una relaci\u00f3n \"es un/una\" entre las entidades, si no \"tiene\" . Por ejemplo: a una persona que le encanta correr se le podr\u00eda clasificar como \"runner\", pero establecerlo como herencia ser\u00eda un error, ya que la persona con el paso del tiempo podr\u00eda dejar de serlo. En este caso, ser\u00eda m\u00e1s correcto decir que tiene el \"rol\" de runner usando la composici\u00f3n, pudi\u00e9ndolo eliminar cuando fuese necesario. No se conocen 100% los requisitos del software y \u00e9stos ser\u00e1n actualizados . Cuando no se conocen por completo los requisitos del sistema es m\u00e1s correcto no establecer relaciones de herencia que pudiesen ser eliminadas posteriormente. Por este motivo, crear clases con las funciones espec\u00edficas y vincularlas a otras haciendo uso de la composici\u00f3n, proporciona mayor flexibilidad y tolerancia a cambios en la implementaci\u00f3n. Adem\u00e1s, permite modularizar el sistemma de forma de que sea posteriormente m\u00e1s facil de mantener.","title":"\u00bfCu\u00e1ndo utilizar la composici\u00f3n?"},{"location":"oop-p1/#polimorfismo-en-la-composicion","text":"La composici\u00f3n por si misma no es polim\u00f3rfica, lo cual puede ser de sus mayores desventajas. No obstante, esto puede ser facilmente solventado con el uso de interfaces. De esta manera, los objetos compuestos implementar\u00e1n las interfaces que interese en cada situaci\u00f3n, consiguiendo a\u00f1adir/eliminar las funciones que implementan sin necesidad de afectar a la funcionalidad propuesta por otras clases. En el ejemplo anterior se puede observar: La clase \"MainActivity\" tiene una funcionalidad dada por un elemento que contiene de la clase \"NavigationDelegate\". Por otro lado, la forma de notificar al resto de clases de que proporciona la funcionalidad \"navigate()\" es implementando la interfaz \"NavigationInterface\". Cuando la clase \"MainActivity\" no deba proporcionar la funcionalidad \"navigate()\" \u00fanicamente debe dejar de implementar la interfaz \"NavigationInterface\" y eliminar la instancia de la clase \"NavigationDelegate\" o dejar de invocar a su funci\u00f3n \"navigate()\".","title":"Polimorfismo en la composici\u00f3n"},{"location":"oop-p1/#herencia-vs-composicion","text":"Como se ha comentado anteriormente, la herencia es un mecanismo muy potente para reutilizar c\u00f3digo fuente, pero no siempre es la mejor t\u00e9cnica para conseguir este objetivo. Ya que, si se usa la herencia de forma inapropiada se puede conseguir software poco seguro y robusto. Adem\u00e1s, el uso de herencia viola el principio de encapsulaci\u00f3n, ya que la subclase siempre depender\u00e1 de la implementaci\u00f3n de los m\u00e9todos en la superclase (a no ser que los sobreescriba), y \u00e9stos m\u00e9todos se actualizar\u00e1n en futuras versiones, con lo que se conseguir\u00e1 incertidumbre en la funcionalidad del c\u00f3digo fuente programado. A continuaci\u00f3n, se muestra una tabla que incluye las diferencias de uso entre la herencia y la composici\u00f3n en algunas de las etapas del desarrollo software y en otros aspectos de inter\u00e9s:","title":"Herencia vs composici\u00f3n"},{"location":"oop-p1/#ejercicios-propuestos","text":"","title":"Ejercicios propuestos"},{"location":"oop-p1/#ejercicio-1","text":"Dado los siguientes fragmentos de c\u00f3digo responder a las siguientes preguntas:","title":"Ejercicio 1"},{"location":"oop-p1/#elementssetjava","text":"public class ElementsSet < E > extends HashSet < E > { //Number of attempted elements insertions using the \"add\" method private int numberOfAddedElements = 0 ; public ElementsSet () {} @Override public boolean add ( E element ) { numberOfAddedElements ++ ; //Counting the element added return super . add ( element ); } @Override public boolean addAll ( Collection <? extends E > elements ) { numberOfAddedElements += elements . size (); //Counting the elements added return super . addAll ( elements ); } public int getNumberOfAddedElements () { return numberOfAddedElements ; } }","title":"ElementsSet.java"},{"location":"oop-p1/#mainjava","text":"... ElementsSet < String > set = new ElementsSet < String > (); set . addAll ( Arrays . asList ( \"One\" , \"Two\" , \"Three\" )); System . out . println ( set . getNumberOfAddedElements ()); ...","title":"Main.java"},{"location":"oop-p1/#preguntas-propuestas","text":"a) \u00bfEs el uso de herencia adecuado para la implementaci\u00f3n de la clase \"ElementsSet\"?, \u00bfqu\u00e9 salida muestra la funci\u00f3n \"System.out.println\" al invocar el m\u00e9todo \"getNumberOfAddedElements\", 3 o 6?. b) En el caso de que haya alg\u00fan problema en la implementaci\u00f3n anterior, proponga una soluci\u00f3n alternativa usando composici\u00f3n que resuelva el problema.","title":"Preguntas propuestas:"},{"location":"oop-p1/#ejercicio-2","text":"","title":"Ejercicio 2"},{"location":"oop-p1/#animaljava","text":"public abstract class Animal { //Number of legs the animal holds protected int numberOfLegs = 0 ; public abstract String speak (); public abstract boolean eat ( String typeOfFeed ); public abstract int getNumberOfLegs (); }","title":"Animal.java"},{"location":"oop-p1/#catjava","text":"public class Cat extends Animal { @Override public String speak () { return \"Meow\" ; } @Override public boolean eat ( String typeOfFeed ) { if ( typeOfFeed . equals ( \"fish\" )) { return true ; } else { return false ; } } @Override public int getNumberOfLegs () { return super . numberOfLegs ; } }","title":"Cat.java"},{"location":"oop-p1/#dogjava","text":"public class Dog extends Animal { @Override public String speak () { return \"Woof\" ; } @Override public boolean eat ( String typeOfFeed ) { if ( typeOfFeed . equals ( \"meat\" )) { return true ; } else { return false ; } } @Override public int getNumberOfLegs () { return super . numberOfLegs ; } }","title":"Dog.java"},{"location":"oop-p1/#mainjava_1","text":"... Animal cat = new Cat (); Animal dog = new Dog (); System . out . println ( cat . speak ()); System . out . println ( dog . speak ()); ...","title":"Main.java"},{"location":"oop-p1/#preguntas-propuestas_1","text":"a) \u00bfEs correcto el uso de herencia en la implementaci\u00f3n de las clases \"Cat\" y \"Dog\"?. \u00bfQu\u00e9 beneficios se obtiene?. b) En el caso de que no sea correcto, proponga una soluci\u00f3n alternativa. \u00bfCu\u00e1les son los beneficios de la soluci\u00f3n propuesta frente a la original?.","title":"Preguntas propuestas:"},{"location":"oop-p1/#referencias","text":"[1] Blog sobre herencia vs composici\u00f3n. [2] Libro effective Java: A programming Language Guide.","title":"Referencias"},{"location":"oop-p2/","text":"Pr\u00e1ctica 2 TO DO","title":"Pr\u00e1ctica 2"},{"location":"oop-p2/#practica-2","text":"","title":"Pr\u00e1ctica 2"},{"location":"oop-p2/#to-do","text":"","title":"TO DO"},{"location":"oop-p3/","text":"Pr\u00e1ctica 3 TO DO","title":"Pr\u00e1ctica 3"},{"location":"oop-p3/#practica-3","text":"","title":"Pr\u00e1ctica 3"},{"location":"oop-p3/#to-do","text":"","title":"TO DO"},{"location":"oop-p4/","text":"Pr\u00e1ctica 4 TO DO","title":"Pr\u00e1ctica 4"},{"location":"oop-p4/#practica-4","text":"","title":"Pr\u00e1ctica 4"},{"location":"oop-p4/#to-do","text":"","title":"TO DO"}]}