{"config":{"lang":["en"],"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Pr\u00e1ticas de Implementaci\u00f3n e Implantaci\u00f3n de Sistemas Software Programaci\u00f3n orientada a objetos \u00b6 Pr\u00e1ctica 1 Pr\u00e1ctica 2 Pr\u00e1ctica 3 Pr\u00e1ctica 4 Programaci\u00f3n funcional \u00b6 Pr\u00e1ctica 1 Pr\u00e1ctica 2 Programaci\u00f3n dirigida por eventos \u00b6 Pr\u00e1ctica 1 Pr\u00e1ctica 2 Pr\u00e1ctica 3","title":"Home"},{"location":"#programacion-orientada-a-objetos","text":"Pr\u00e1ctica 1 Pr\u00e1ctica 2 Pr\u00e1ctica 3 Pr\u00e1ctica 4","title":"Programaci\u00f3n orientada a objetos"},{"location":"#programacion-funcional","text":"Pr\u00e1ctica 1 Pr\u00e1ctica 2","title":"Programaci\u00f3n funcional"},{"location":"#programacion-dirigida-por-eventos","text":"Pr\u00e1ctica 1 Pr\u00e1ctica 2 Pr\u00e1ctica 3","title":"Programaci\u00f3n dirigida por eventos"},{"location":"ep-p1/","text":"Pr\u00e1ctica 1 TO DO \u00b6","title":"Pr\u00e1ctica 1"},{"location":"ep-p1/#to-do","text":"","title":"TO DO"},{"location":"ep-p2/","text":"Pr\u00e1ctica 2 TO DO \u00b6","title":"Pr\u00e1ctica 2"},{"location":"ep-p2/#to-do","text":"","title":"TO DO"},{"location":"ep-p3/","text":"Pr\u00e1ctica 3 TO DO \u00b6","title":"Pr\u00e1ctica 3"},{"location":"ep-p3/#to-do","text":"","title":"TO DO"},{"location":"fp-p1/","text":"Pr\u00e1ctica 1 TO DO \u00b6","title":"Pr\u00e1ctica 1"},{"location":"fp-p1/#to-do","text":"","title":"TO DO"},{"location":"fp-p2/","text":"Pr\u00e1ctica 2 TO DO \u00b6","title":"Pr\u00e1ctica 2"},{"location":"fp-p2/#to-do","text":"","title":"TO DO"},{"location":"oop-p1/","text":"Pr\u00e1ctica 1: Herencia, composici\u00f3n y polimorfismo Repaso de conceptos te\u00f3ricos \u00b6 Herencia \u00b6 Definici\u00f3n \u00b6 Se puede definir la herencia como el mecanismo por el cual una clase permite heredar sus caracter\u00edsticas (atributos y m\u00e9todos) a otra clase. Este mecanismo puede ser usado para la reutilizaci\u00f3n de c\u00f3digo, la cual permite realizar extensiones independientes del software original. por Carlos Villag\u00f3mez, Enciclopedia de Programaci\u00f3n Orientada a Objetos En el ejemplo de la imagen anterior existe una jerarqu\u00eda de herencia de tres niveles en los que: Todas las clases heredan las funciones y propiedades de la clase \"Animal\". La clase \"Conejo\" hereda las funciones y propiedades de la clase \"Herb\u00edvoro\", las clases \"Le\u00f3n\" y \"Hiena\" las de la clase \"Carn\u00edvoro\" y la clase \"Hombre\" las de la clase \"Omn\u00edvoro\". \u00bfCu\u00e1ndo utilizar la herencia? \u00b6 La herencia debe ser utilizada cuando se cumplen al menos las siguientes condiciones: Existe una relaci\u00f3n \"es un/una\" entre las entidades . Por ejemplo: un le\u00f3n o una hiena son animales, pero un animal no tiene porque ser un le\u00f3n (puede ser cualquiera de las otras subclases). Esto es debido a que la relaci\u00f3n de herencia es unidireccional. Se conoce el 100% de los requisitos del software y \u00e9stos no van a cambiar . Si se conoce perfectamente los requisitos del software que se va a implementar y estos no van a cambiar, se puede deducir las relaciones de herencia que existir\u00e1n entre las clases desde el principio. No obstante, en cualquier otro caso puede ser costoso durante el desarrollo eliminar/mantener estas relaciones si los requisitos van evolucionando en otro sentido. Por ejemplo, esto suceder\u00eda dentro de un proyecto donde se aplica una metodolog\u00eda de desarrollo \u00e1gil. Polimorfismo en la herencia \u00b6 La herencia otorga la propiedad de polimorfismo, que significa que cualquiera de las subclases pueden adoptar la forma de la superclase. Esta es una de las principales ventajas de la herencia, ya que el polimorfismo permite la abstracci\u00f3n del objeto concreto y usar su superclase. Por ejemplo, podr\u00edamos tratar cualquier instancia de la clase \"Hombre\" o \"Le\u00f3n\" como una instancia de la clase \"Animal\", ya que han herendado todas sus funciones y propiedades. Pero no al contrario, ya que la clase \"Le\u00f3n\" podr\u00eda haber a\u00f1adido nuevas propiedades o funciones que no est\u00e9n disponibles en la clase \"Animal\". \u00bfCu\u00e1les son las ventajas de la herencia? \u00b6 Las ventajas que nos propone el uso de la herencia son las siguientes: Permite reutilizar c\u00f3digo de una manera r\u00e1pida y sencilla. Permite el uso del polimorfismo con facilidad. Permite sobreescribir m\u00e9todos, adapt\u00e1ndolos a necesidades espec\u00edficas. Permite crear clases abstractas que hacen de plantilla a las subclases (parecido al patr\u00f3n de dise\u00f1o \"Template Method\"). Composici\u00f3n \u00b6 Definici\u00f3n \u00b6 La composici\u00f3n se basa en la creaci\u00f3n de clases que realizar\u00e1n una \u00fanica y espec\u00edfica funci\u00f3n que complementaran a otras clases, las cuales estar\u00e1n compuestas por ellas. Este mecanismo, nos permitir\u00e1 delegar las funciones a aquellas clases que se han implementado \u00fanicamente para cubrirlas, reutilizando su c\u00f3digo fuente donde sea necesario. por Arturo Verbel de Le\u00f3n, Diagrama de clases para dummies En el ejemplo anterior se puede observar: La clase \"Empresa\" esta compuesta por instancias de la clase \"Empleado\". La clase \"Empleado\" es el compuesto de la clase \"Empresa\", de hecho se establece una relaci\u00f3n donde la cardinalidad es 1..N por lo que la clase \"Empresa\" en su implementaci\u00f3n mantendr\u00e1 una lista de instancias de la clase \"Empleado\". \u00bfCu\u00e1ndo utilizar la composici\u00f3n? \u00b6 La composici\u00f3n debe ser utilizada cuando se cumplen al menos las siguientes condiciones: No existe una relaci\u00f3n \"es un/una\" entre las entidades, si no \"tiene\" . Por ejemplo: a una persona que le encanta correr se le podr\u00eda clasificar como \"runner\", pero establecerlo como herencia ser\u00eda un error, ya que la persona con el paso del tiempo podr\u00eda dejar de serlo. En este caso, ser\u00eda m\u00e1s correcto decir que tiene el \"rol\" de runner usando la composici\u00f3n, pudi\u00e9ndolo eliminar cuando fuese necesario. No se conocen 100% los requisitos del software y \u00e9stos ser\u00e1n actualizados . Cuando no se conocen por completo los requisitos del sistema es m\u00e1s correcto no establecer relaciones de herencia que pudiesen ser eliminadas posteriormente. Por este motivo, crear clases con las funciones espec\u00edficas y vincularlas a otras haciendo uso de la composici\u00f3n, proporciona mayor flexibilidad y tolerancia a cambios en la implementaci\u00f3n. Adem\u00e1s, permite modularizar el sistemma de forma de que sea posteriormente m\u00e1s facil de mantener. Polimorfismo en la composici\u00f3n \u00b6 La composici\u00f3n por si misma no es polim\u00f3rfica, lo cual puede ser de sus mayores desventajas. No obstante, esto puede ser facilmente solventado con el uso de interfaces. De esta manera, los objetos compuestos implementar\u00e1n las interfaces que interese en cada situaci\u00f3n, consiguiendo a\u00f1adir/eliminar las funciones que implementan sin necesidad de afectar a la funcionalidad propuesta por otras clases. por Sergio Mart\u00ednez Rodr\u00edguez, Herencia vs Composici\u00f3n \u00bfTienes claro cu\u00e1l es el rival m\u00e1s d\u00e9bil? En el ejemplo anterior se puede observar: La clase \"MainActivity\" tiene una funcionalidad dada por un elemento que contiene de la clase \"NavigationDelegate\". Por otro lado, la forma de notificar al resto de clases de que proporciona la funcionalidad \"navigate()\" es implementando la interfaz \"NavigationInterface\". Cuando la clase \"MainActivity\" no deba proporcionar la funcionalidad \"navigate()\" \u00fanicamente debe dejar de implementar la interfaz \"NavigationInterface\" y eliminar la instancia de la clase \"NavigationDelegate\" o dejar de invocar a su funci\u00f3n \"navigate()\". Herencia vs composici\u00f3n \u00b6 Como se ha comentado anteriormente, la herencia es un mecanismo muy potente para reutilizar c\u00f3digo fuente, pero no siempre es la mejor t\u00e9cnica para conseguir este objetivo. Ya que, si se usa la herencia de forma inapropiada se puede conseguir software poco seguro y robusto. Adem\u00e1s, el uso de herencia viola el principio de encapsulaci\u00f3n, ya que la subclase siempre depender\u00e1 de la implementaci\u00f3n de los m\u00e9todos en la superclase (a no ser que los sobreescriba), y \u00e9stos m\u00e9todos se actualizar\u00e1n en futuras versiones, con lo que se conseguir\u00e1 incertidumbre en la funcionalidad del c\u00f3digo fuente programado. A continuaci\u00f3n, se muestra una tabla que incluye las diferencias de uso entre la herencia y la composici\u00f3n en algunas de las etapas del desarrollo software y en otros aspectos de inter\u00e9s: por Sergio Mart\u00ednez Rodr\u00edguez, Herencia vs Composici\u00f3n \u00bfTienes claro cu\u00e1l es el rival m\u00e1s d\u00e9bil? Ejercicios propuestos \u00b6 Ejercicio 1 \u00b6 Dado los siguientes fragmentos de c\u00f3digo responder a las siguientes preguntas: ElementsSet.java \u00b6 public class ElementsSet < E > extends HashSet < E > { //Number of attempted elements insertions using the \"add\" method private int numberOfAddedElements = 0 ; public ElementsSet () {} @Override public boolean add ( E element ) { numberOfAddedElements ++ ; //Counting the element added return super . add ( element ); } @Override public boolean addAll ( Collection <? extends E > elements ) { numberOfAddedElements += elements . size (); //Counting the elements added return super . addAll ( elements ); } public int getNumberOfAddedElements () { return numberOfAddedElements ; } } Main.java \u00b6 ... ElementsSet < String > set = new ElementsSet < String > (); set . addAll ( Arrays . asList ( \"One\" , \"Two\" , \"Three\" )); System . out . println ( set . getNumberOfAddedElements ()); ... Preguntas propuestas \u00b6 a) \u00bfEs el uso de herencia adecuado para la implementaci\u00f3n de la clase \"ElementsSet\"?, \u00bfqu\u00e9 salida muestra la funci\u00f3n \"System.out.println\" al invocar el m\u00e9todo \"getNumberOfAddedElements\", 3 o 6?. b) En el caso de que haya alg\u00fan problema en la implementaci\u00f3n anterior, proponga una soluci\u00f3n alternativa usando composici\u00f3n que resuelva el problema. Ejercicio 2 \u00b6 Dado los siguientes fragmentos de c\u00f3digo responder a las siguientes preguntas: Animal.java \u00b6 public abstract class Animal { //Number of legs the animal holds protected int numberOfLegs = 0 ; public abstract String speak (); public abstract boolean eat ( String typeOfFeed ); public abstract int getNumberOfLegs (); } Cat.java \u00b6 public class Cat extends Animal { @Override public String speak () { return \"Meow\" ; } @Override public boolean eat ( String typeOfFeed ) { if ( typeOfFeed . equals ( \"fish\" )) { return true ; } else { return false ; } } @Override public int getNumberOfLegs () { return super . numberOfLegs ; } } Dog.java \u00b6 public class Dog extends Animal { @Override public String speak () { return \"Woof\" ; } @Override public boolean eat ( String typeOfFeed ) { if ( typeOfFeed . equals ( \"meat\" )) { return true ; } else { return false ; } } @Override public int getNumberOfLegs () { return super . numberOfLegs ; } } Main.java \u00b6 ... Animal cat = new Cat (); Animal dog = new Dog (); System . out . println ( cat . speak ()); System . out . println ( dog . speak ()); ... Preguntas propuestas \u00b6 a) \u00bfEs correcto el uso de herencia en la implementaci\u00f3n de las clases \"Cat\" y \"Dog\"?. \u00bfQu\u00e9 beneficios se obtiene?. b) En el caso de que no sea correcto, proponga una soluci\u00f3n alternativa. \u00bfCu\u00e1les son los beneficios de la soluci\u00f3n propuesta frente a la original?. Referencias \u00b6 [1] Blog Herencia vs Composici\u00f3n \u00bfTienes claro cu\u00e1l es el rival m\u00e1s d\u00e9bil?. [2] Libro Effective Java: A programming Language Guide.","title":"Pr\u00e1ctica 1"},{"location":"oop-p1/#repaso-de-conceptos-teoricos","text":"","title":"Repaso de conceptos te\u00f3ricos"},{"location":"oop-p1/#herencia","text":"","title":"Herencia"},{"location":"oop-p1/#definicion","text":"Se puede definir la herencia como el mecanismo por el cual una clase permite heredar sus caracter\u00edsticas (atributos y m\u00e9todos) a otra clase. Este mecanismo puede ser usado para la reutilizaci\u00f3n de c\u00f3digo, la cual permite realizar extensiones independientes del software original. por Carlos Villag\u00f3mez, Enciclopedia de Programaci\u00f3n Orientada a Objetos En el ejemplo de la imagen anterior existe una jerarqu\u00eda de herencia de tres niveles en los que: Todas las clases heredan las funciones y propiedades de la clase \"Animal\". La clase \"Conejo\" hereda las funciones y propiedades de la clase \"Herb\u00edvoro\", las clases \"Le\u00f3n\" y \"Hiena\" las de la clase \"Carn\u00edvoro\" y la clase \"Hombre\" las de la clase \"Omn\u00edvoro\".","title":"Definici\u00f3n"},{"location":"oop-p1/#cuando-utilizar-la-herencia","text":"La herencia debe ser utilizada cuando se cumplen al menos las siguientes condiciones: Existe una relaci\u00f3n \"es un/una\" entre las entidades . Por ejemplo: un le\u00f3n o una hiena son animales, pero un animal no tiene porque ser un le\u00f3n (puede ser cualquiera de las otras subclases). Esto es debido a que la relaci\u00f3n de herencia es unidireccional. Se conoce el 100% de los requisitos del software y \u00e9stos no van a cambiar . Si se conoce perfectamente los requisitos del software que se va a implementar y estos no van a cambiar, se puede deducir las relaciones de herencia que existir\u00e1n entre las clases desde el principio. No obstante, en cualquier otro caso puede ser costoso durante el desarrollo eliminar/mantener estas relaciones si los requisitos van evolucionando en otro sentido. Por ejemplo, esto suceder\u00eda dentro de un proyecto donde se aplica una metodolog\u00eda de desarrollo \u00e1gil.","title":"\u00bfCu\u00e1ndo utilizar la herencia?"},{"location":"oop-p1/#polimorfismo-en-la-herencia","text":"La herencia otorga la propiedad de polimorfismo, que significa que cualquiera de las subclases pueden adoptar la forma de la superclase. Esta es una de las principales ventajas de la herencia, ya que el polimorfismo permite la abstracci\u00f3n del objeto concreto y usar su superclase. Por ejemplo, podr\u00edamos tratar cualquier instancia de la clase \"Hombre\" o \"Le\u00f3n\" como una instancia de la clase \"Animal\", ya que han herendado todas sus funciones y propiedades. Pero no al contrario, ya que la clase \"Le\u00f3n\" podr\u00eda haber a\u00f1adido nuevas propiedades o funciones que no est\u00e9n disponibles en la clase \"Animal\".","title":"Polimorfismo en la herencia"},{"location":"oop-p1/#cuales-son-las-ventajas-de-la-herencia","text":"Las ventajas que nos propone el uso de la herencia son las siguientes: Permite reutilizar c\u00f3digo de una manera r\u00e1pida y sencilla. Permite el uso del polimorfismo con facilidad. Permite sobreescribir m\u00e9todos, adapt\u00e1ndolos a necesidades espec\u00edficas. Permite crear clases abstractas que hacen de plantilla a las subclases (parecido al patr\u00f3n de dise\u00f1o \"Template Method\").","title":"\u00bfCu\u00e1les son las ventajas de la herencia?"},{"location":"oop-p1/#composicion","text":"","title":"Composici\u00f3n"},{"location":"oop-p1/#definicion_1","text":"La composici\u00f3n se basa en la creaci\u00f3n de clases que realizar\u00e1n una \u00fanica y espec\u00edfica funci\u00f3n que complementaran a otras clases, las cuales estar\u00e1n compuestas por ellas. Este mecanismo, nos permitir\u00e1 delegar las funciones a aquellas clases que se han implementado \u00fanicamente para cubrirlas, reutilizando su c\u00f3digo fuente donde sea necesario. por Arturo Verbel de Le\u00f3n, Diagrama de clases para dummies En el ejemplo anterior se puede observar: La clase \"Empresa\" esta compuesta por instancias de la clase \"Empleado\". La clase \"Empleado\" es el compuesto de la clase \"Empresa\", de hecho se establece una relaci\u00f3n donde la cardinalidad es 1..N por lo que la clase \"Empresa\" en su implementaci\u00f3n mantendr\u00e1 una lista de instancias de la clase \"Empleado\".","title":"Definici\u00f3n"},{"location":"oop-p1/#cuando-utilizar-la-composicion","text":"La composici\u00f3n debe ser utilizada cuando se cumplen al menos las siguientes condiciones: No existe una relaci\u00f3n \"es un/una\" entre las entidades, si no \"tiene\" . Por ejemplo: a una persona que le encanta correr se le podr\u00eda clasificar como \"runner\", pero establecerlo como herencia ser\u00eda un error, ya que la persona con el paso del tiempo podr\u00eda dejar de serlo. En este caso, ser\u00eda m\u00e1s correcto decir que tiene el \"rol\" de runner usando la composici\u00f3n, pudi\u00e9ndolo eliminar cuando fuese necesario. No se conocen 100% los requisitos del software y \u00e9stos ser\u00e1n actualizados . Cuando no se conocen por completo los requisitos del sistema es m\u00e1s correcto no establecer relaciones de herencia que pudiesen ser eliminadas posteriormente. Por este motivo, crear clases con las funciones espec\u00edficas y vincularlas a otras haciendo uso de la composici\u00f3n, proporciona mayor flexibilidad y tolerancia a cambios en la implementaci\u00f3n. Adem\u00e1s, permite modularizar el sistemma de forma de que sea posteriormente m\u00e1s facil de mantener.","title":"\u00bfCu\u00e1ndo utilizar la composici\u00f3n?"},{"location":"oop-p1/#polimorfismo-en-la-composicion","text":"La composici\u00f3n por si misma no es polim\u00f3rfica, lo cual puede ser de sus mayores desventajas. No obstante, esto puede ser facilmente solventado con el uso de interfaces. De esta manera, los objetos compuestos implementar\u00e1n las interfaces que interese en cada situaci\u00f3n, consiguiendo a\u00f1adir/eliminar las funciones que implementan sin necesidad de afectar a la funcionalidad propuesta por otras clases. por Sergio Mart\u00ednez Rodr\u00edguez, Herencia vs Composici\u00f3n \u00bfTienes claro cu\u00e1l es el rival m\u00e1s d\u00e9bil? En el ejemplo anterior se puede observar: La clase \"MainActivity\" tiene una funcionalidad dada por un elemento que contiene de la clase \"NavigationDelegate\". Por otro lado, la forma de notificar al resto de clases de que proporciona la funcionalidad \"navigate()\" es implementando la interfaz \"NavigationInterface\". Cuando la clase \"MainActivity\" no deba proporcionar la funcionalidad \"navigate()\" \u00fanicamente debe dejar de implementar la interfaz \"NavigationInterface\" y eliminar la instancia de la clase \"NavigationDelegate\" o dejar de invocar a su funci\u00f3n \"navigate()\".","title":"Polimorfismo en la composici\u00f3n"},{"location":"oop-p1/#herencia-vs-composicion","text":"Como se ha comentado anteriormente, la herencia es un mecanismo muy potente para reutilizar c\u00f3digo fuente, pero no siempre es la mejor t\u00e9cnica para conseguir este objetivo. Ya que, si se usa la herencia de forma inapropiada se puede conseguir software poco seguro y robusto. Adem\u00e1s, el uso de herencia viola el principio de encapsulaci\u00f3n, ya que la subclase siempre depender\u00e1 de la implementaci\u00f3n de los m\u00e9todos en la superclase (a no ser que los sobreescriba), y \u00e9stos m\u00e9todos se actualizar\u00e1n en futuras versiones, con lo que se conseguir\u00e1 incertidumbre en la funcionalidad del c\u00f3digo fuente programado. A continuaci\u00f3n, se muestra una tabla que incluye las diferencias de uso entre la herencia y la composici\u00f3n en algunas de las etapas del desarrollo software y en otros aspectos de inter\u00e9s: por Sergio Mart\u00ednez Rodr\u00edguez, Herencia vs Composici\u00f3n \u00bfTienes claro cu\u00e1l es el rival m\u00e1s d\u00e9bil?","title":"Herencia vs composici\u00f3n"},{"location":"oop-p1/#ejercicios-propuestos","text":"","title":"Ejercicios propuestos"},{"location":"oop-p1/#ejercicio-1","text":"Dado los siguientes fragmentos de c\u00f3digo responder a las siguientes preguntas:","title":"Ejercicio 1"},{"location":"oop-p1/#elementssetjava","text":"public class ElementsSet < E > extends HashSet < E > { //Number of attempted elements insertions using the \"add\" method private int numberOfAddedElements = 0 ; public ElementsSet () {} @Override public boolean add ( E element ) { numberOfAddedElements ++ ; //Counting the element added return super . add ( element ); } @Override public boolean addAll ( Collection <? extends E > elements ) { numberOfAddedElements += elements . size (); //Counting the elements added return super . addAll ( elements ); } public int getNumberOfAddedElements () { return numberOfAddedElements ; } }","title":"ElementsSet.java"},{"location":"oop-p1/#mainjava","text":"... ElementsSet < String > set = new ElementsSet < String > (); set . addAll ( Arrays . asList ( \"One\" , \"Two\" , \"Three\" )); System . out . println ( set . getNumberOfAddedElements ()); ...","title":"Main.java"},{"location":"oop-p1/#preguntas-propuestas","text":"a) \u00bfEs el uso de herencia adecuado para la implementaci\u00f3n de la clase \"ElementsSet\"?, \u00bfqu\u00e9 salida muestra la funci\u00f3n \"System.out.println\" al invocar el m\u00e9todo \"getNumberOfAddedElements\", 3 o 6?. b) En el caso de que haya alg\u00fan problema en la implementaci\u00f3n anterior, proponga una soluci\u00f3n alternativa usando composici\u00f3n que resuelva el problema.","title":"Preguntas propuestas"},{"location":"oop-p1/#ejercicio-2","text":"Dado los siguientes fragmentos de c\u00f3digo responder a las siguientes preguntas:","title":"Ejercicio 2"},{"location":"oop-p1/#animaljava","text":"public abstract class Animal { //Number of legs the animal holds protected int numberOfLegs = 0 ; public abstract String speak (); public abstract boolean eat ( String typeOfFeed ); public abstract int getNumberOfLegs (); }","title":"Animal.java"},{"location":"oop-p1/#catjava","text":"public class Cat extends Animal { @Override public String speak () { return \"Meow\" ; } @Override public boolean eat ( String typeOfFeed ) { if ( typeOfFeed . equals ( \"fish\" )) { return true ; } else { return false ; } } @Override public int getNumberOfLegs () { return super . numberOfLegs ; } }","title":"Cat.java"},{"location":"oop-p1/#dogjava","text":"public class Dog extends Animal { @Override public String speak () { return \"Woof\" ; } @Override public boolean eat ( String typeOfFeed ) { if ( typeOfFeed . equals ( \"meat\" )) { return true ; } else { return false ; } } @Override public int getNumberOfLegs () { return super . numberOfLegs ; } }","title":"Dog.java"},{"location":"oop-p1/#mainjava_1","text":"... Animal cat = new Cat (); Animal dog = new Dog (); System . out . println ( cat . speak ()); System . out . println ( dog . speak ()); ...","title":"Main.java"},{"location":"oop-p1/#preguntas-propuestas_1","text":"a) \u00bfEs correcto el uso de herencia en la implementaci\u00f3n de las clases \"Cat\" y \"Dog\"?. \u00bfQu\u00e9 beneficios se obtiene?. b) En el caso de que no sea correcto, proponga una soluci\u00f3n alternativa. \u00bfCu\u00e1les son los beneficios de la soluci\u00f3n propuesta frente a la original?.","title":"Preguntas propuestas"},{"location":"oop-p1/#referencias","text":"[1] Blog Herencia vs Composici\u00f3n \u00bfTienes claro cu\u00e1l es el rival m\u00e1s d\u00e9bil?. [2] Libro Effective Java: A programming Language Guide.","title":"Referencias"},{"location":"oop-p2/","text":"Pr\u00e1ctica 2: Refactoring Repaso de conceptos te\u00f3ricos \u00b6 Refactoring \u00b6 Definici\u00f3n \u00b6 El proceso de refactoring es un proceso sistem\u00e1tico, en el cual se pretende cambiar la estructura del software implementado para hacerlo m\u00e1s f\u00e1cil de entender y m\u00e1s r\u00e1pido de modificar sin cambiar su comportamiento. Es decir, en este proceso se pretende mejorar la calidad del c\u00f3digo fuente sin crear nueva funcionalidad. Refactoring is a controlled technique for improving the design of an existing code base. Its essence is applying a series of small behavior-preserving transformations, each of which \"too small to be worth doing\". However the cumulative effect of each of these transformations is quite significant. By doing them in small steps you reduce the risk of introducing errors. You also avoid having the system broken while you are carrying out the restructuring \u2014 which allows you to gradually refactor a system over an extended period of time. -- Martin Fowler Por lo tanto, en el proceso de refactorizaci\u00f3n se deben realizar peque\u00f1as modificaciones, las cuales sean manejables y vayan incrementando gradualmente la limpieza de c\u00f3digo mientras se mantiene la funcionalidad del mismo. Conforme se realizan estos cambios, se comienza a transformar el c\u00f3digo inicial en un c\u00f3digo m\u00e1s simple, m\u00e1s f\u00e1cil de leer y m\u00e1s mantenible. No es una simple refactorizaci\u00f3n lo que realiza el cambio, si no el efecto acumulativo de muchos peque\u00f1os \"refactorings\" realizados hac\u00eda un s\u00f3lo objetivo. por Justin Albano, What Is Refactoring? Razones para refactorizar \u00b6 A continuaci\u00f3n, seg\u00fan [1] se listan las posibles razones que promueven la refactorizaci\u00f3n del c\u00f3digo: C\u00f3digo duplicado. Una funci\u00f3n es demasiado larga. Un bucle es demasiado largo o est\u00e1 demasiado anidado (demasiada complejidad). Una clase tiene poca cohesi\u00f3n. Una interfaz no proporciona un nivel consistente de abstracci\u00f3n. Una lista de par\u00e1metros tiene demasiados par\u00e1metros. Los cambios dentro de una clase tienden a afectar a otras clases. Las jerarqu\u00edas de herencia tienen que ser modificadas en paralelo (afecta a todas las subclases un mismo cambio). Los atributos que se utilizan por varias clases no est\u00e1n organizados en una clase (se repiten). Una funci\u00f3n utiliza m\u00e1s caracter\u00edsticas propuestas por otra clase que de su propia clase. Un tipo de datos primitivo esta sobrecargado. Una clase no tiene una finalidad clara (no aporta mucho). Un objeto intermediario no hace nada. Una funci\u00f3n tiene un nombre que no especifica de forma clara su objetivo. Los atributos de una clase son p\u00fablicos. Una subclase s\u00f3lo utiliza un porcentaje m\u00ednimo de las funciones que hereda. Se utilizan comentarios para explicar c\u00f3digo d\u00edficil de entender. Se usan variables globales. Una funci\u00f3n contiene c\u00f3digo que parece que ser\u00e1 necesario alg\u00fan d\u00eda pero en la actualidad no se utiliza. Resumen de posibles refactorizaciones \u00b6 Finalmente, a continuaci\u00f3n se incluye algunas de las posibles refactorizaciones propuestas en [1] . La aplicaci\u00f3n de estas t\u00e9cnicas de refactorizaci\u00f3n depender\u00e1 de si en el softare implementado se encuentran alguno/s de los problemas incluidos en la lista anterior: Refactorizaci\u00f3n en el uso de datos \u00b6 Reemplazar un n\u00famero utilizado directamente por una constante. Renombrar una variable para darle un nombre m\u00e1s claro o explicativo. Convertir una variable que se usa en m\u00faltiples sitios en m\u00faltiples variables de \u00fanico uso. Usar una variable local para prop\u00f3sitos locales en lugar de un par\u00e1metro de una funci\u00f3n. Convertir el uso de datos primitivos en el uso de una clase. Convertir un array (de bajo nivel) en un objeto. Encapsular una colecci\u00f3n. Refactorizaci\u00f3n en la implementaci\u00f3n de sentencias/instrucciones \u00b6 Descomponer una expresi\u00f3n l\u00f3gica. Convertir una expresi\u00f3n l\u00f3gica compleja en una funci\u00f3n l\u00f3gica con un nombre correcto para su definici\u00f3n. Unificar fragmentos de c\u00f3digo duplicado en diferentes partes de una expresi\u00f3n condicional. Eliminar el uso de \"break\" o \"return\" en lugar del uso de variables de control en los bucles. Devolver lo m\u00e1s r\u00e1pido posible la soluci\u00f3n en lugar de asignar el valor a una variable dentro de instrucciones if-else. Reemplazar condicionales (especialmente las sentencias \"case\") por el uso de polimorfismo. Refactorizaci\u00f3n en la implementaci\u00f3n de funciones \u00b6 Extraer una funci\u00f3n desde c\u00f3digo que se repite en varios lugares. Convertir una funci\u00f3n demasiado larga en una clase. Sustituir un algoritmo complejo por uno simple. Combinar funciones similares en una \u00fanica. Pasar el objeto completo en lugar de seleccionar algunos campos espec\u00edficos (en el caso de que sean muchos). Pasar algunos campos espec\u00edficos en lugar del objeto completo (en el caso de que sean pocos campos los utilizados). Refactorizaci\u00f3n en la implementaci\u00f3n de clases/interfaces \u00b6 Extraer c\u00f3digo especializado en subclases. Combinar c\u00f3digo similar en superclases. Mover una funci\u00f3n a otra clase en la que tenga m\u00e1s coherencia. Convertir una clase demasiado larga en dos. Eliminar una clase sin utilidad. Reemplazar herencia por composici\u00f3n (en el caso de que sea necesario). Reemplazar composici\u00f3n por herencia (en el caso de que sea necesario). Unificar una superclase y una subclase si su implementaci\u00f3n es muy similar. Refactorizaci\u00f3n a nivel de sistema \u00b6 Cambiar la asociaci\u00f3n unidireccional de clases a bidireccional (en caso de que sea necesario). Cambiar la asociaci\u00f3n bidireccional de clases a unidireccional (en caso de que sea necesario). Proveer de una factoria para crear los objetos en lugar de usar un constructor simple. Reemplazar los c\u00f3digos de error con excepciones (en caso de que sea necesario). Uso de Streams + expresiones Lambda en Java \u00b6 Un stream representa una secuencia de elementos que soportan diferentes tipos de operaciones que permiten realizar c\u00e1lculos sobre ellos. Las posibles operaciones que se pueden realizar sobre un stream pueden ser intermediarias o terminales. Las operaciones intermediarias devuelven un nuevo stream permitiendo encadenar m\u00faltiples operaciones intermediarias sin usar punto y coma. Por otro lado, las operaciones terminales son nulas o devuelven un resultado de un tipo diferente, por ejemplo un tipo num\u00e9rico. por Benjamin, Java 8 Stream Tutorial En el ejemplo anterior, las operaciones filter , map y sorted son operaciones intermediarias, mientras que la operaci\u00f3n forEach es una operaci\u00f3n terminal. M\u00e1s informaci\u00f3n: https://www.oracle.com/technetwork/es/articles/java/procesamiento-streams-java-se-8-2763402-esa.html Por otro lado, se puede observar que la mayor\u00eda de las operaciones que se aplican sobre streams aceptan alg\u00fan tipo de par\u00e1metro en forma de expresi\u00f3n lambda , la cual es una interfaz funcional que especifica el comportamiento exacto de la operaci\u00f3n. Estas operaciones no pueden modificar el contenido del stream original. En el ejemplo anterior, se puede observar que ninguna de las operaciones modifica la variable myList a\u00f1adiendo o eliminando elementos, s\u00f3lo se realiza el filtrado de los elementos que no empiezan por \"c\", se transforman a may\u00fasculas, se ordenan en orden alfab\u00e9tico y se imprimen por pantalla. M\u00e1s informaci\u00f3n: https://www.oracle.com/technetwork/es/articles/java/expresiones-lambda-api-stream-java-2737544-esa.html Ejercicios propuestos \u00b6 Ejercicio 1 \u00b6 Dado los siguientes fragmentos de c\u00f3digo responder a las siguientes preguntas: GroupOfUsers.java \u00b6 public class GroupOfUsers { private static Map < String , Integer > usersWithPoints = new HashMap < String , Integer > () {{ put ( \"User1\" , 800 ); put ( \"User2\" , 550 ); put ( \"User3\" , 20 ); put ( \"User4\" , 300 ); }}; public List < String > getUsers () { List < String > users = new ArrayList < String > (); //Sorting users by points usersWithPoints . entrySet () . stream () . sorted ( Map . Entry . < String , Integer > comparingByValue (). reversed ()) . forEachOrdered ( x -> users . add ( x . getKey ())); //Capitalizing the names of the users List < String > usersCapitalized = new ArrayList < String > (); users . forEach ( x -> usersCapitalized . add ( x . toUpperCase ())); return usersCapitalized ; } } Main.java \u00b6 ... GroupOfUsers group = new GroupOfUsers (); List < String > users = group . getUsers (); System . out . println ( \"The users are: \" + users ); ... Preguntas propuestas \u00b6 En la siguiente lista se incluyen 10 posibles problemas que pueden encontrarse en el c\u00f3digo de la implementaci\u00f3n anterior: C\u00f3digo duplicado. Funciones con nombre que no especifica de forma clara su objetivo. Rutinas demasiado largas. Bucles demasiado largos o demasiado anidados. Funciones con demasiada responsabilidad (no tienen asignada una \u00fanica responsabilidad u operaci\u00f3n a resolver). Lista de par\u00e1metros con demasiados par\u00e1metros. Los cambios de una clase tienden a afectar a otras. Se utilizan comentarios para explicar c\u00f3digo d\u00edficil de entender. Se usan variables globales. Los cambios dentro de una clase tienden a afectar a otras clases. a) \u00bfExiste alg\u00fan tipo de problema en la implementaci\u00f3n anterior de los que se incluye en la lista anterior?, \u00bfes necesario aplicar refactoring en este caso?. En el caso de que existan problemas, indique cu\u00e1les son y qu\u00e9 tipos de problemas piensa que generar\u00edan en el futuro si no se aplica el refactoring ahora. b) En el caso de que la implementaci\u00f3n necesite la aplicaci\u00f3n de refactoring, realice los cambios oportunos e indique las mejoras que aporta su implementaci\u00f3n respecto a la original. Ejercicio 2 \u00b6 Dado los siguientes fragmentos de c\u00f3digo responder a las siguientes preguntas: GroupOfUsers.java \u00b6 public class GroupOfUsers { private static Map < String , Integer > usersWithPoints_Group1 = new HashMap < String , Integer > () {{ put ( \"User1\" , 800 ); put ( \"User2\" , 550 ); put ( \"User3\" , 20 ); put ( \"User4\" , 300 ); }}; private static Map < String , Integer > usersWithPoints_Group2 = new HashMap < String , Integer > () {{ put ( \"User1\" , 10 ); put ( \"User2\" , 990 ); put ( \"User3\" , 760 ); put ( \"User4\" , 230 ); }}; private static Map < String , Integer > usersWithPoints_Group3 = new HashMap < String , Integer > () {{ put ( \"User1\" , 1000 ); put ( \"User2\" , 200 ); put ( \"User3\" , 5 ); put ( \"User4\" , 780 ); }}; public List < ArrayList < String >> getUsers () { List < String > users1 = new ArrayList < String > (); List < String > users2 = new ArrayList < String > (); List < String > users3 = new ArrayList < String > (); List < ArrayList < String >> users = new ArrayList < ArrayList < String >> (); //Sorting users by points usersWithPoints_Group1 . entrySet () . stream () . sorted ( Map . Entry . < String , Integer > comparingByValue (). reversed ()) . forEachOrdered ( x -> users1 . add ( x . getKey ())); usersWithPoints_Group2 . entrySet () . stream () . sorted ( Map . Entry . < String , Integer > comparingByValue (). reversed ()) . forEachOrdered ( x -> users2 . add ( x . getKey ())); usersWithPoints_Group3 . entrySet () . stream () . sorted ( Map . Entry . < String , Integer > comparingByValue (). reversed ()) . forEachOrdered ( x -> users3 . add ( x . getKey ())); //Capitalizing the names of the users List < String > usersCapitalized1 = new ArrayList < String > (); List < String > usersCapitalized2 = new ArrayList < String > (); List < String > usersCapitalized3 = new ArrayList < String > (); users1 . forEach ( x -> usersCapitalized1 . add ( x . toUpperCase ())); users2 . forEach ( x -> usersCapitalized2 . add ( x . toUpperCase ())); users3 . forEach ( x -> usersCapitalized3 . add ( x . toUpperCase ())); //Adding users to the main list users . add (( ArrayList < String > ) usersCapitalized1 ); users . add (( ArrayList < String > ) usersCapitalized2 ); users . add (( ArrayList < String > ) usersCapitalized3 ); return users ; } } Main.java \u00b6 ... GroupOfUsers group = new GroupOfUsers (); List < ArrayList < String >> users = group . getUsers (); System . out . println ( \"The users are: \" + users ); ... Preguntas propuestas \u00b6 Responda a las siguientes cuestiones teniendo en cuenta la lista de los 10 posibles problemas incluida en el ejercicio anterior. a) El software del ejercicio anterior ha evolucionado a\u00f1adiendo nueva funcionalidad en su implementaci\u00f3n. \u00bfExiste alg\u00fan tipo de problema en esta versi\u00f3n de la implementaci\u00f3n de los que se incluyen en la lista?, \u00bfes necesario aplicar refactoring en este caso?. En el caso de que existan problemas, indique cu\u00e1les son y qu\u00e9 tipos de problemas piensa que generar\u00edan en el futuro si no se aplica el refactoring ahora. b) En el caso de que la implementaci\u00f3n necesite la aplicaci\u00f3n de refactoring, realice los cambios oportunos e indique las mejoras que aporta su implementaci\u00f3n respecto a la original. Referencias \u00b6 [1] Libro Code Complete: A Practical Handbook of Software Construction, Second Edition. [2] Blog What Is Refactoring.","title":"Pr\u00e1ctica 2"},{"location":"oop-p2/#repaso-de-conceptos-teoricos","text":"","title":"Repaso de conceptos te\u00f3ricos"},{"location":"oop-p2/#refactoring","text":"","title":"Refactoring"},{"location":"oop-p2/#definicion","text":"El proceso de refactoring es un proceso sistem\u00e1tico, en el cual se pretende cambiar la estructura del software implementado para hacerlo m\u00e1s f\u00e1cil de entender y m\u00e1s r\u00e1pido de modificar sin cambiar su comportamiento. Es decir, en este proceso se pretende mejorar la calidad del c\u00f3digo fuente sin crear nueva funcionalidad. Refactoring is a controlled technique for improving the design of an existing code base. Its essence is applying a series of small behavior-preserving transformations, each of which \"too small to be worth doing\". However the cumulative effect of each of these transformations is quite significant. By doing them in small steps you reduce the risk of introducing errors. You also avoid having the system broken while you are carrying out the restructuring \u2014 which allows you to gradually refactor a system over an extended period of time. -- Martin Fowler Por lo tanto, en el proceso de refactorizaci\u00f3n se deben realizar peque\u00f1as modificaciones, las cuales sean manejables y vayan incrementando gradualmente la limpieza de c\u00f3digo mientras se mantiene la funcionalidad del mismo. Conforme se realizan estos cambios, se comienza a transformar el c\u00f3digo inicial en un c\u00f3digo m\u00e1s simple, m\u00e1s f\u00e1cil de leer y m\u00e1s mantenible. No es una simple refactorizaci\u00f3n lo que realiza el cambio, si no el efecto acumulativo de muchos peque\u00f1os \"refactorings\" realizados hac\u00eda un s\u00f3lo objetivo. por Justin Albano, What Is Refactoring?","title":"Definici\u00f3n"},{"location":"oop-p2/#razones-para-refactorizar","text":"A continuaci\u00f3n, seg\u00fan [1] se listan las posibles razones que promueven la refactorizaci\u00f3n del c\u00f3digo: C\u00f3digo duplicado. Una funci\u00f3n es demasiado larga. Un bucle es demasiado largo o est\u00e1 demasiado anidado (demasiada complejidad). Una clase tiene poca cohesi\u00f3n. Una interfaz no proporciona un nivel consistente de abstracci\u00f3n. Una lista de par\u00e1metros tiene demasiados par\u00e1metros. Los cambios dentro de una clase tienden a afectar a otras clases. Las jerarqu\u00edas de herencia tienen que ser modificadas en paralelo (afecta a todas las subclases un mismo cambio). Los atributos que se utilizan por varias clases no est\u00e1n organizados en una clase (se repiten). Una funci\u00f3n utiliza m\u00e1s caracter\u00edsticas propuestas por otra clase que de su propia clase. Un tipo de datos primitivo esta sobrecargado. Una clase no tiene una finalidad clara (no aporta mucho). Un objeto intermediario no hace nada. Una funci\u00f3n tiene un nombre que no especifica de forma clara su objetivo. Los atributos de una clase son p\u00fablicos. Una subclase s\u00f3lo utiliza un porcentaje m\u00ednimo de las funciones que hereda. Se utilizan comentarios para explicar c\u00f3digo d\u00edficil de entender. Se usan variables globales. Una funci\u00f3n contiene c\u00f3digo que parece que ser\u00e1 necesario alg\u00fan d\u00eda pero en la actualidad no se utiliza.","title":"Razones para refactorizar"},{"location":"oop-p2/#resumen-de-posibles-refactorizaciones","text":"Finalmente, a continuaci\u00f3n se incluye algunas de las posibles refactorizaciones propuestas en [1] . La aplicaci\u00f3n de estas t\u00e9cnicas de refactorizaci\u00f3n depender\u00e1 de si en el softare implementado se encuentran alguno/s de los problemas incluidos en la lista anterior:","title":"Resumen de posibles refactorizaciones"},{"location":"oop-p2/#refactorizacion-en-el-uso-de-datos","text":"Reemplazar un n\u00famero utilizado directamente por una constante. Renombrar una variable para darle un nombre m\u00e1s claro o explicativo. Convertir una variable que se usa en m\u00faltiples sitios en m\u00faltiples variables de \u00fanico uso. Usar una variable local para prop\u00f3sitos locales en lugar de un par\u00e1metro de una funci\u00f3n. Convertir el uso de datos primitivos en el uso de una clase. Convertir un array (de bajo nivel) en un objeto. Encapsular una colecci\u00f3n.","title":"Refactorizaci\u00f3n en el uso de datos"},{"location":"oop-p2/#refactorizacion-en-la-implementacion-de-sentenciasinstrucciones","text":"Descomponer una expresi\u00f3n l\u00f3gica. Convertir una expresi\u00f3n l\u00f3gica compleja en una funci\u00f3n l\u00f3gica con un nombre correcto para su definici\u00f3n. Unificar fragmentos de c\u00f3digo duplicado en diferentes partes de una expresi\u00f3n condicional. Eliminar el uso de \"break\" o \"return\" en lugar del uso de variables de control en los bucles. Devolver lo m\u00e1s r\u00e1pido posible la soluci\u00f3n en lugar de asignar el valor a una variable dentro de instrucciones if-else. Reemplazar condicionales (especialmente las sentencias \"case\") por el uso de polimorfismo.","title":"Refactorizaci\u00f3n en la implementaci\u00f3n de sentencias/instrucciones"},{"location":"oop-p2/#refactorizacion-en-la-implementacion-de-funciones","text":"Extraer una funci\u00f3n desde c\u00f3digo que se repite en varios lugares. Convertir una funci\u00f3n demasiado larga en una clase. Sustituir un algoritmo complejo por uno simple. Combinar funciones similares en una \u00fanica. Pasar el objeto completo en lugar de seleccionar algunos campos espec\u00edficos (en el caso de que sean muchos). Pasar algunos campos espec\u00edficos en lugar del objeto completo (en el caso de que sean pocos campos los utilizados).","title":"Refactorizaci\u00f3n en la implementaci\u00f3n de funciones"},{"location":"oop-p2/#refactorizacion-en-la-implementacion-de-clasesinterfaces","text":"Extraer c\u00f3digo especializado en subclases. Combinar c\u00f3digo similar en superclases. Mover una funci\u00f3n a otra clase en la que tenga m\u00e1s coherencia. Convertir una clase demasiado larga en dos. Eliminar una clase sin utilidad. Reemplazar herencia por composici\u00f3n (en el caso de que sea necesario). Reemplazar composici\u00f3n por herencia (en el caso de que sea necesario). Unificar una superclase y una subclase si su implementaci\u00f3n es muy similar.","title":"Refactorizaci\u00f3n en la implementaci\u00f3n de clases/interfaces"},{"location":"oop-p2/#refactorizacion-a-nivel-de-sistema","text":"Cambiar la asociaci\u00f3n unidireccional de clases a bidireccional (en caso de que sea necesario). Cambiar la asociaci\u00f3n bidireccional de clases a unidireccional (en caso de que sea necesario). Proveer de una factoria para crear los objetos en lugar de usar un constructor simple. Reemplazar los c\u00f3digos de error con excepciones (en caso de que sea necesario).","title":"Refactorizaci\u00f3n a nivel de sistema"},{"location":"oop-p2/#uso-de-streams-expresiones-lambda-en-java","text":"Un stream representa una secuencia de elementos que soportan diferentes tipos de operaciones que permiten realizar c\u00e1lculos sobre ellos. Las posibles operaciones que se pueden realizar sobre un stream pueden ser intermediarias o terminales. Las operaciones intermediarias devuelven un nuevo stream permitiendo encadenar m\u00faltiples operaciones intermediarias sin usar punto y coma. Por otro lado, las operaciones terminales son nulas o devuelven un resultado de un tipo diferente, por ejemplo un tipo num\u00e9rico. por Benjamin, Java 8 Stream Tutorial En el ejemplo anterior, las operaciones filter , map y sorted son operaciones intermediarias, mientras que la operaci\u00f3n forEach es una operaci\u00f3n terminal. M\u00e1s informaci\u00f3n: https://www.oracle.com/technetwork/es/articles/java/procesamiento-streams-java-se-8-2763402-esa.html Por otro lado, se puede observar que la mayor\u00eda de las operaciones que se aplican sobre streams aceptan alg\u00fan tipo de par\u00e1metro en forma de expresi\u00f3n lambda , la cual es una interfaz funcional que especifica el comportamiento exacto de la operaci\u00f3n. Estas operaciones no pueden modificar el contenido del stream original. En el ejemplo anterior, se puede observar que ninguna de las operaciones modifica la variable myList a\u00f1adiendo o eliminando elementos, s\u00f3lo se realiza el filtrado de los elementos que no empiezan por \"c\", se transforman a may\u00fasculas, se ordenan en orden alfab\u00e9tico y se imprimen por pantalla. M\u00e1s informaci\u00f3n: https://www.oracle.com/technetwork/es/articles/java/expresiones-lambda-api-stream-java-2737544-esa.html","title":"Uso de Streams + expresiones Lambda en Java"},{"location":"oop-p2/#ejercicios-propuestos","text":"","title":"Ejercicios propuestos"},{"location":"oop-p2/#ejercicio-1","text":"Dado los siguientes fragmentos de c\u00f3digo responder a las siguientes preguntas:","title":"Ejercicio 1"},{"location":"oop-p2/#groupofusersjava","text":"public class GroupOfUsers { private static Map < String , Integer > usersWithPoints = new HashMap < String , Integer > () {{ put ( \"User1\" , 800 ); put ( \"User2\" , 550 ); put ( \"User3\" , 20 ); put ( \"User4\" , 300 ); }}; public List < String > getUsers () { List < String > users = new ArrayList < String > (); //Sorting users by points usersWithPoints . entrySet () . stream () . sorted ( Map . Entry . < String , Integer > comparingByValue (). reversed ()) . forEachOrdered ( x -> users . add ( x . getKey ())); //Capitalizing the names of the users List < String > usersCapitalized = new ArrayList < String > (); users . forEach ( x -> usersCapitalized . add ( x . toUpperCase ())); return usersCapitalized ; } }","title":"GroupOfUsers.java"},{"location":"oop-p2/#mainjava","text":"... GroupOfUsers group = new GroupOfUsers (); List < String > users = group . getUsers (); System . out . println ( \"The users are: \" + users ); ...","title":"Main.java"},{"location":"oop-p2/#preguntas-propuestas","text":"En la siguiente lista se incluyen 10 posibles problemas que pueden encontrarse en el c\u00f3digo de la implementaci\u00f3n anterior: C\u00f3digo duplicado. Funciones con nombre que no especifica de forma clara su objetivo. Rutinas demasiado largas. Bucles demasiado largos o demasiado anidados. Funciones con demasiada responsabilidad (no tienen asignada una \u00fanica responsabilidad u operaci\u00f3n a resolver). Lista de par\u00e1metros con demasiados par\u00e1metros. Los cambios de una clase tienden a afectar a otras. Se utilizan comentarios para explicar c\u00f3digo d\u00edficil de entender. Se usan variables globales. Los cambios dentro de una clase tienden a afectar a otras clases. a) \u00bfExiste alg\u00fan tipo de problema en la implementaci\u00f3n anterior de los que se incluye en la lista anterior?, \u00bfes necesario aplicar refactoring en este caso?. En el caso de que existan problemas, indique cu\u00e1les son y qu\u00e9 tipos de problemas piensa que generar\u00edan en el futuro si no se aplica el refactoring ahora. b) En el caso de que la implementaci\u00f3n necesite la aplicaci\u00f3n de refactoring, realice los cambios oportunos e indique las mejoras que aporta su implementaci\u00f3n respecto a la original.","title":"Preguntas propuestas"},{"location":"oop-p2/#ejercicio-2","text":"Dado los siguientes fragmentos de c\u00f3digo responder a las siguientes preguntas:","title":"Ejercicio 2"},{"location":"oop-p2/#groupofusersjava_1","text":"public class GroupOfUsers { private static Map < String , Integer > usersWithPoints_Group1 = new HashMap < String , Integer > () {{ put ( \"User1\" , 800 ); put ( \"User2\" , 550 ); put ( \"User3\" , 20 ); put ( \"User4\" , 300 ); }}; private static Map < String , Integer > usersWithPoints_Group2 = new HashMap < String , Integer > () {{ put ( \"User1\" , 10 ); put ( \"User2\" , 990 ); put ( \"User3\" , 760 ); put ( \"User4\" , 230 ); }}; private static Map < String , Integer > usersWithPoints_Group3 = new HashMap < String , Integer > () {{ put ( \"User1\" , 1000 ); put ( \"User2\" , 200 ); put ( \"User3\" , 5 ); put ( \"User4\" , 780 ); }}; public List < ArrayList < String >> getUsers () { List < String > users1 = new ArrayList < String > (); List < String > users2 = new ArrayList < String > (); List < String > users3 = new ArrayList < String > (); List < ArrayList < String >> users = new ArrayList < ArrayList < String >> (); //Sorting users by points usersWithPoints_Group1 . entrySet () . stream () . sorted ( Map . Entry . < String , Integer > comparingByValue (). reversed ()) . forEachOrdered ( x -> users1 . add ( x . getKey ())); usersWithPoints_Group2 . entrySet () . stream () . sorted ( Map . Entry . < String , Integer > comparingByValue (). reversed ()) . forEachOrdered ( x -> users2 . add ( x . getKey ())); usersWithPoints_Group3 . entrySet () . stream () . sorted ( Map . Entry . < String , Integer > comparingByValue (). reversed ()) . forEachOrdered ( x -> users3 . add ( x . getKey ())); //Capitalizing the names of the users List < String > usersCapitalized1 = new ArrayList < String > (); List < String > usersCapitalized2 = new ArrayList < String > (); List < String > usersCapitalized3 = new ArrayList < String > (); users1 . forEach ( x -> usersCapitalized1 . add ( x . toUpperCase ())); users2 . forEach ( x -> usersCapitalized2 . add ( x . toUpperCase ())); users3 . forEach ( x -> usersCapitalized3 . add ( x . toUpperCase ())); //Adding users to the main list users . add (( ArrayList < String > ) usersCapitalized1 ); users . add (( ArrayList < String > ) usersCapitalized2 ); users . add (( ArrayList < String > ) usersCapitalized3 ); return users ; } }","title":"GroupOfUsers.java"},{"location":"oop-p2/#mainjava_1","text":"... GroupOfUsers group = new GroupOfUsers (); List < ArrayList < String >> users = group . getUsers (); System . out . println ( \"The users are: \" + users ); ...","title":"Main.java"},{"location":"oop-p2/#preguntas-propuestas_1","text":"Responda a las siguientes cuestiones teniendo en cuenta la lista de los 10 posibles problemas incluida en el ejercicio anterior. a) El software del ejercicio anterior ha evolucionado a\u00f1adiendo nueva funcionalidad en su implementaci\u00f3n. \u00bfExiste alg\u00fan tipo de problema en esta versi\u00f3n de la implementaci\u00f3n de los que se incluyen en la lista?, \u00bfes necesario aplicar refactoring en este caso?. En el caso de que existan problemas, indique cu\u00e1les son y qu\u00e9 tipos de problemas piensa que generar\u00edan en el futuro si no se aplica el refactoring ahora. b) En el caso de que la implementaci\u00f3n necesite la aplicaci\u00f3n de refactoring, realice los cambios oportunos e indique las mejoras que aporta su implementaci\u00f3n respecto a la original.","title":"Preguntas propuestas"},{"location":"oop-p2/#referencias","text":"[1] Libro Code Complete: A Practical Handbook of Software Construction, Second Edition. [2] Blog What Is Refactoring.","title":"Referencias"},{"location":"oop-p3/","text":"Pr\u00e1ctica 3 Repaso de conceptos te\u00f3ricos \u00b6 Las dos t\u00e9cnicas siguientes, la inyecci\u00f3n de dependencias y la programaci\u00f3n de aspectos, nos permiten implementar el principio de ortogonalidad entre componentes software. Inyecci\u00f3n de dependencias \u00b6 La inyecci\u00f3n de dependencias es una t\u00e9cnica utilizada para implementar la inversi\u00f3n de control (IC, se invierte el flujo tradicional del programa). Por este motivo, permite la creaci\u00f3n de objetos fuera de una clase y proporciona esos objetos a otra clase dependiente de ellos de diferentes formas. Utilizando la IC, se traslada la creaci\u00f3n y uni\u00f3n de los objetos fuera de la clase que depende de ellos. por TutorialsTeacher, Dependency Injection A continuaci\u00f3n, se describen los tipos de inyecci\u00f3n de dependencias existentes: Inyecci\u00f3n a trav\u00e9s del constructor : En este tipo de inyecci\u00f3n la clase inyectora suministra la dependencia (servicio) a trav\u00e9s del constructor de la clase dependente (cliente). Inyecci\u00f3n a trav\u00e9s de propiedades : En este tipo de inyecci\u00f3n la clase inyectora suministra la dependenca (servicio) a trav\u00e9s de un m\u00e9todo \"set\" de la clase dependiente (cliente). Inyecci\u00f3n a trav\u00e9s de m\u00e9todos : En este tipo de inyecci\u00f3n la clase inyectora suministra la dependencia (servicio) a trav\u00e9s de un API establecido por la clase dependiente en el que se especifican el/los m\u00e9todo/s para suministrar la dependencia (cliente). Frameworks para facilitar la implementaci\u00f3n de inyecci\u00f3n de dependencias en Java: https://www.vogella.com/tutorials/DependencyInjection/article.html . Programaci\u00f3n orientada a aspectos \u00b6 Los aspectos nos permiten agrupar c\u00f3digo que se ejecutar\u00e1 en varios lugares en un m\u00f3dulo independiente. Adem\u00e1s, este c\u00f3digo ser\u00e1 inyectado en tiempo de ejecuci\u00f3n o compilaci\u00f3n (dependiendo del framework) en los puntos de corte especificados en el c\u00f3digo fuente. En este caso, la programaci\u00f3n orientada a aspectos (AOP) permite introducir nueva funcionalidad dentro de una clase, sin que \u00e9sta deba tener conocimiento de su existencia. Aspect-oriented programming (AOP) complements object-oriented programming by allowing the developer to dynamically modify the static object-oriented model to create a system that can grow to meet new requirements, allowing an application to adopt new characteristics as it develops. -- Vangie Beal AspectJ, framework para facilitar la implementaci\u00f3n de inyecci\u00f3n de dependencias en Java: https://www.eclipse.org/aspectj/doc/released/progguide/starting.html Ejercicios propuestos \u00b6 Ejercicio 1 \u00b6 Dado los siguientes fragmentos de c\u00f3digo responder a las siguientes preguntas: DBAccess.java \u00b6 public interface DBAccess { public void initConnection (); } DBAccessA.java \u00b6 public class DBAccessA implements DBAccess { public DBAccessA () {} public void initConnection () { System . out . println ( \"Init A connection with database..\" ); } } DBAccessB.java \u00b6 public class DBAccessB implements DBAccess { public DBAccessB () {} public void initConnection () { System . out . println ( \"Init B connection with database..\" ); } } DBClient.java \u00b6 public class DBClient { private DBAccess dbAccess ; public DBClient ( DBAccess dbAccess ) { this . dbAccess = dbAccess ; } public void setDBAccess ( DBAccess dbAccess ) { this . dbAccess = dbAccess ; } public void getAllFromDataBase () { dbAccess . initConnection (); System . out . println ( \"Returning all data from database..\" ); } public void getSomeDataFromDataBase () { dbAccess . initConnection (); System . out . println ( \"Returning some data from database..\" ); } } Main.java \u00b6 public class Main { public static void main ( String args [] ) { DBAccess dbAccessB = new DBAccessB (); DBClient client = new DBClient ( dbAccessB ); System . out . println ( \"Querying all data from database..\" ); client . getAllFromDataBase (); DBAccess dbAccessA = new DBAccessA (); client . setDBAccess ( dbAccessA ); System . out . println ( \"Querying some data from database..\" ); client . getSomeDataFromDataBase (); } } Preguntas propuestas \u00b6 a) \u00bfSe realiza inyecci\u00f3n de dependencias entre las clases anteriores?, si es as\u00ed identifique la clase inyectora, el servicio y el cliente. b) En el caso de que exista inyecci\u00f3n de dependencias adem\u00e1s indique: El m\u00e9todo de inyecci\u00f3n que se realiza (constructor, propiedad o m\u00e9todo). La/s l\u00ednea/s donde se realiza la inyecci\u00f3n de dependencias. Ejercicio 2 \u00b6 Dado los siguientes fragmentos de c\u00f3digo responder a las siguientes preguntas: Bank.java \u00b6 public class Bank { public Bank () {} public void createUser () { System . out . println ( \"Creating user..\" ); } public void makeTransaction () { System . out . println ( \"Making transaction..\" ); } public void takeMoneyOut () { System . out . println ( \"Taking money out..\" ); } public void showUsers () { System . out . println ( \"Showing users..\" ); } } Main.java \u00b6 public class Main { private static Scanner input = new Scanner ( System . in ); public static void main ( String args [] ) { System . out . println ( \"AspectJ Bank\" ); System . out . println ( \"------------\" ); System . out . println ( \"1 - Create user\" ); System . out . println ( \"2 - Make transaction\" ); System . out . println ( \"3 - Take money out\" ); System . out . println ( \"4 - Show users\" ); System . out . println ( \"5 - Exit\" ); int option = Integer . valueOf ( input . nextLine ()); Bank bank = new Bank (); switch ( option ) { case 1 : bank . createUser (); break ; case 2 : bank . makeTransaction (); break ; case 3 : bank . takeMoneyOut (); break ; case 4 : bank . showUsers (); break ; case 5 : System . out . println ( \"Exiting..\" ); break ; } } } LoginAspect.java \u00b6 import org.aspectj.lang.JoinPoint ; import org.aspectj.lang.annotation.After ; import org.aspectj.lang.annotation.Aspect ; import org.aspectj.lang.annotation.Before ; @Aspect public class LoginAspect { @Before ( \"..TO-DO..\" ) public void before ( JoinPoint joinPoint ){ //...TO-DO.. } @After ( \"..TO-DO..\" ) public void after ( JoinPoint joinPoint ){ //...TO-DO.. } } Preguntas propuestas \u00b6 Complete en la clase \"LoginAspect.java\" las secciones \"TO-DO\" de forma que se cumplan las siguientes condiciones: a) Mostrar el mensaje \"The login is required\" antes de la ejecuci\u00f3n de las operaciones \"makeTransaction\" y \"takeMoneyOut\". b) Mostrar el mensaje \"The database is empty\" despu\u00e9s de la ejecuci\u00f3n de la operaci\u00f3n \"showUsers\". c) Sustituya el fichero \"LoginAspect.java\" por el fichero \"LoginAspect.aj\" incluyendo la misma funcionalidad utilizando la sintaxis de AspectJ.","title":"Pr\u00e1ctica 3"},{"location":"oop-p3/#repaso-de-conceptos-teoricos","text":"Las dos t\u00e9cnicas siguientes, la inyecci\u00f3n de dependencias y la programaci\u00f3n de aspectos, nos permiten implementar el principio de ortogonalidad entre componentes software.","title":"Repaso de conceptos te\u00f3ricos"},{"location":"oop-p3/#inyeccion-de-dependencias","text":"La inyecci\u00f3n de dependencias es una t\u00e9cnica utilizada para implementar la inversi\u00f3n de control (IC, se invierte el flujo tradicional del programa). Por este motivo, permite la creaci\u00f3n de objetos fuera de una clase y proporciona esos objetos a otra clase dependiente de ellos de diferentes formas. Utilizando la IC, se traslada la creaci\u00f3n y uni\u00f3n de los objetos fuera de la clase que depende de ellos. por TutorialsTeacher, Dependency Injection A continuaci\u00f3n, se describen los tipos de inyecci\u00f3n de dependencias existentes: Inyecci\u00f3n a trav\u00e9s del constructor : En este tipo de inyecci\u00f3n la clase inyectora suministra la dependencia (servicio) a trav\u00e9s del constructor de la clase dependente (cliente). Inyecci\u00f3n a trav\u00e9s de propiedades : En este tipo de inyecci\u00f3n la clase inyectora suministra la dependenca (servicio) a trav\u00e9s de un m\u00e9todo \"set\" de la clase dependiente (cliente). Inyecci\u00f3n a trav\u00e9s de m\u00e9todos : En este tipo de inyecci\u00f3n la clase inyectora suministra la dependencia (servicio) a trav\u00e9s de un API establecido por la clase dependiente en el que se especifican el/los m\u00e9todo/s para suministrar la dependencia (cliente). Frameworks para facilitar la implementaci\u00f3n de inyecci\u00f3n de dependencias en Java: https://www.vogella.com/tutorials/DependencyInjection/article.html .","title":"Inyecci\u00f3n de dependencias"},{"location":"oop-p3/#programacion-orientada-a-aspectos","text":"Los aspectos nos permiten agrupar c\u00f3digo que se ejecutar\u00e1 en varios lugares en un m\u00f3dulo independiente. Adem\u00e1s, este c\u00f3digo ser\u00e1 inyectado en tiempo de ejecuci\u00f3n o compilaci\u00f3n (dependiendo del framework) en los puntos de corte especificados en el c\u00f3digo fuente. En este caso, la programaci\u00f3n orientada a aspectos (AOP) permite introducir nueva funcionalidad dentro de una clase, sin que \u00e9sta deba tener conocimiento de su existencia. Aspect-oriented programming (AOP) complements object-oriented programming by allowing the developer to dynamically modify the static object-oriented model to create a system that can grow to meet new requirements, allowing an application to adopt new characteristics as it develops. -- Vangie Beal AspectJ, framework para facilitar la implementaci\u00f3n de inyecci\u00f3n de dependencias en Java: https://www.eclipse.org/aspectj/doc/released/progguide/starting.html","title":"Programaci\u00f3n orientada a aspectos"},{"location":"oop-p3/#ejercicios-propuestos","text":"","title":"Ejercicios propuestos"},{"location":"oop-p3/#ejercicio-1","text":"Dado los siguientes fragmentos de c\u00f3digo responder a las siguientes preguntas:","title":"Ejercicio 1"},{"location":"oop-p3/#dbaccessjava","text":"public interface DBAccess { public void initConnection (); }","title":"DBAccess.java"},{"location":"oop-p3/#dbaccessajava","text":"public class DBAccessA implements DBAccess { public DBAccessA () {} public void initConnection () { System . out . println ( \"Init A connection with database..\" ); } }","title":"DBAccessA.java"},{"location":"oop-p3/#dbaccessbjava","text":"public class DBAccessB implements DBAccess { public DBAccessB () {} public void initConnection () { System . out . println ( \"Init B connection with database..\" ); } }","title":"DBAccessB.java"},{"location":"oop-p3/#dbclientjava","text":"public class DBClient { private DBAccess dbAccess ; public DBClient ( DBAccess dbAccess ) { this . dbAccess = dbAccess ; } public void setDBAccess ( DBAccess dbAccess ) { this . dbAccess = dbAccess ; } public void getAllFromDataBase () { dbAccess . initConnection (); System . out . println ( \"Returning all data from database..\" ); } public void getSomeDataFromDataBase () { dbAccess . initConnection (); System . out . println ( \"Returning some data from database..\" ); } }","title":"DBClient.java"},{"location":"oop-p3/#mainjava","text":"public class Main { public static void main ( String args [] ) { DBAccess dbAccessB = new DBAccessB (); DBClient client = new DBClient ( dbAccessB ); System . out . println ( \"Querying all data from database..\" ); client . getAllFromDataBase (); DBAccess dbAccessA = new DBAccessA (); client . setDBAccess ( dbAccessA ); System . out . println ( \"Querying some data from database..\" ); client . getSomeDataFromDataBase (); } }","title":"Main.java"},{"location":"oop-p3/#preguntas-propuestas","text":"a) \u00bfSe realiza inyecci\u00f3n de dependencias entre las clases anteriores?, si es as\u00ed identifique la clase inyectora, el servicio y el cliente. b) En el caso de que exista inyecci\u00f3n de dependencias adem\u00e1s indique: El m\u00e9todo de inyecci\u00f3n que se realiza (constructor, propiedad o m\u00e9todo). La/s l\u00ednea/s donde se realiza la inyecci\u00f3n de dependencias.","title":"Preguntas propuestas"},{"location":"oop-p3/#ejercicio-2","text":"Dado los siguientes fragmentos de c\u00f3digo responder a las siguientes preguntas:","title":"Ejercicio 2"},{"location":"oop-p3/#bankjava","text":"public class Bank { public Bank () {} public void createUser () { System . out . println ( \"Creating user..\" ); } public void makeTransaction () { System . out . println ( \"Making transaction..\" ); } public void takeMoneyOut () { System . out . println ( \"Taking money out..\" ); } public void showUsers () { System . out . println ( \"Showing users..\" ); } }","title":"Bank.java"},{"location":"oop-p3/#mainjava_1","text":"public class Main { private static Scanner input = new Scanner ( System . in ); public static void main ( String args [] ) { System . out . println ( \"AspectJ Bank\" ); System . out . println ( \"------------\" ); System . out . println ( \"1 - Create user\" ); System . out . println ( \"2 - Make transaction\" ); System . out . println ( \"3 - Take money out\" ); System . out . println ( \"4 - Show users\" ); System . out . println ( \"5 - Exit\" ); int option = Integer . valueOf ( input . nextLine ()); Bank bank = new Bank (); switch ( option ) { case 1 : bank . createUser (); break ; case 2 : bank . makeTransaction (); break ; case 3 : bank . takeMoneyOut (); break ; case 4 : bank . showUsers (); break ; case 5 : System . out . println ( \"Exiting..\" ); break ; } } }","title":"Main.java"},{"location":"oop-p3/#loginaspectjava","text":"import org.aspectj.lang.JoinPoint ; import org.aspectj.lang.annotation.After ; import org.aspectj.lang.annotation.Aspect ; import org.aspectj.lang.annotation.Before ; @Aspect public class LoginAspect { @Before ( \"..TO-DO..\" ) public void before ( JoinPoint joinPoint ){ //...TO-DO.. } @After ( \"..TO-DO..\" ) public void after ( JoinPoint joinPoint ){ //...TO-DO.. } }","title":"LoginAspect.java"},{"location":"oop-p3/#preguntas-propuestas_1","text":"Complete en la clase \"LoginAspect.java\" las secciones \"TO-DO\" de forma que se cumplan las siguientes condiciones: a) Mostrar el mensaje \"The login is required\" antes de la ejecuci\u00f3n de las operaciones \"makeTransaction\" y \"takeMoneyOut\". b) Mostrar el mensaje \"The database is empty\" despu\u00e9s de la ejecuci\u00f3n de la operaci\u00f3n \"showUsers\". c) Sustituya el fichero \"LoginAspect.java\" por el fichero \"LoginAspect.aj\" incluyendo la misma funcionalidad utilizando la sintaxis de AspectJ.","title":"Preguntas propuestas"},{"location":"oop-p4/","text":"Pr\u00e1ctica 4 TO DO \u00b6","title":"Pr\u00e1ctica 4"},{"location":"oop-p4/#to-do","text":"","title":"TO DO"}]}